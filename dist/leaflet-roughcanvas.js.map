{"version":3,"file":"leaflet-roughcanvas.js","sources":["../node_modules/roughjs/bin/path.js","../node_modules/roughjs/bin/geometry.js","../node_modules/roughjs/bin/utils/hachure.js","../node_modules/roughjs/bin/fillers/filler-utils.js","../node_modules/roughjs/bin/fillers/hachure-filler.js","../node_modules/roughjs/bin/fillers/zigzag-filler.js","../node_modules/roughjs/bin/fillers/hatch-filler.js","../node_modules/roughjs/bin/fillers/dot-filler.js","../node_modules/roughjs/bin/fillers/filler.js","../node_modules/roughjs/bin/renderer.js","../node_modules/roughjs/bin/renderer-factory.js","../node_modules/roughjs/bin/generator-base.js","../node_modules/roughjs/bin/generator.js","../node_modules/roughjs/bin/canvas-base.js","../node_modules/roughjs/bin/canvas.js","../node_modules/roughjs/bin/generator-async.js","../node_modules/roughjs/bin/canvas-async.js","../node_modules/roughjs/bin/rough.js","../node_modules/canvas-5-polyfill/canvas.js","../src/main.js"],"sourcesContent":["function isType(token, type) {\n    return token.type === type;\n}\nconst PARAMS = {\n    A: 7,\n    a: 7,\n    C: 6,\n    c: 6,\n    H: 1,\n    h: 1,\n    L: 2,\n    l: 2,\n    M: 2,\n    m: 2,\n    Q: 4,\n    q: 4,\n    S: 4,\n    s: 4,\n    T: 4,\n    t: 2,\n    V: 1,\n    v: 1,\n    Z: 0,\n    z: 0\n};\nclass ParsedPath {\n    constructor(d) {\n        this.COMMAND = 0;\n        this.NUMBER = 1;\n        this.EOD = 2;\n        this.segments = [];\n        this.parseData(d);\n        this.processPoints();\n    }\n    tokenize(d) {\n        const tokens = new Array();\n        while (d !== '') {\n            if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n                tokens[tokens.length] = { type: this.COMMAND, text: RegExp.$1 };\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n                tokens[tokens.length] = { type: this.NUMBER, text: `${parseFloat(RegExp.$1)}` };\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                console.error('Unrecognized segment command: ' + d);\n                return [];\n            }\n        }\n        tokens[tokens.length] = { type: this.EOD, text: '' };\n        return tokens;\n    }\n    parseData(d) {\n        const tokens = this.tokenize(d);\n        let index = 0;\n        let token = tokens[index];\n        let mode = 'BOD';\n        this.segments = new Array();\n        while (!isType(token, this.EOD)) {\n            let param_length;\n            const params = new Array();\n            if (mode === 'BOD') {\n                if (token.text === 'M' || token.text === 'm') {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n                else {\n                    this.parseData('M0,0' + d);\n                    return;\n                }\n            }\n            else {\n                if (isType(token, this.NUMBER)) {\n                    param_length = PARAMS[mode];\n                }\n                else {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n            }\n            if ((index + param_length) < tokens.length) {\n                for (let i = index; i < index + param_length; i++) {\n                    const numbeToken = tokens[i];\n                    if (isType(numbeToken, this.NUMBER)) {\n                        params[params.length] = +numbeToken.text;\n                    }\n                    else {\n                        console.error('Parameter type is not a number: ' + mode + ',' + numbeToken.text);\n                        return;\n                    }\n                }\n                if (typeof PARAMS[mode] === 'number') {\n                    const segment = { key: mode, data: params };\n                    this.segments.push(segment);\n                    index += param_length;\n                    token = tokens[index];\n                    if (mode === 'M')\n                        mode = 'L';\n                    if (mode === 'm')\n                        mode = 'l';\n                }\n                else {\n                    console.error('Unsupported segment type: ' + mode);\n                    return;\n                }\n            }\n            else {\n                console.error('Path data ended before all parameters were found');\n            }\n        }\n    }\n    get closed() {\n        if (typeof this._closed === 'undefined') {\n            this._closed = false;\n            for (const s of this.segments) {\n                if (s.key.toLowerCase() === 'z') {\n                    this._closed = true;\n                }\n            }\n        }\n        return this._closed;\n    }\n    processPoints() {\n        let first = null;\n        let currentPoint = [0, 0];\n        for (let i = 0; i < this.segments.length; i++) {\n            const s = this.segments[i];\n            switch (s.key) {\n                case 'M':\n                case 'L':\n                case 'T':\n                    s.point = [s.data[0], s.data[1]];\n                    break;\n                case 'm':\n                case 'l':\n                case 't':\n                    s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n                    break;\n                case 'H':\n                    s.point = [s.data[0], currentPoint[1]];\n                    break;\n                case 'h':\n                    s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n                    break;\n                case 'V':\n                    s.point = [currentPoint[0], s.data[0]];\n                    break;\n                case 'v':\n                    s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n                    break;\n                case 'z':\n                case 'Z':\n                    if (first) {\n                        s.point = [first[0], first[1]];\n                    }\n                    break;\n                case 'C':\n                    s.point = [s.data[4], s.data[5]];\n                    break;\n                case 'c':\n                    s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n                    break;\n                case 'S':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 's':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'Q':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 'q':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'A':\n                    s.point = [s.data[5], s.data[6]];\n                    break;\n                case 'a':\n                    s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n                    break;\n            }\n            if (s.key === 'm' || s.key === 'M') {\n                first = null;\n            }\n            if (s.point) {\n                currentPoint = s.point;\n                if (!first) {\n                    first = s.point;\n                }\n            }\n            if (s.key === 'z' || s.key === 'Z') {\n                first = null;\n            }\n        }\n    }\n}\nexport class RoughPath {\n    constructor(d) {\n        this._position = [0, 0];\n        this._first = null;\n        this.bezierReflectionPoint = null;\n        this.quadReflectionPoint = null;\n        this.parsed = new ParsedPath(d);\n    }\n    get segments() {\n        return this.parsed.segments;\n    }\n    get closed() {\n        return this.parsed.closed;\n    }\n    get linearPoints() {\n        if (!this._linearPoints) {\n            const lp = [];\n            let points = [];\n            for (const s of this.parsed.segments) {\n                const key = s.key.toLowerCase();\n                if (key === 'm' || key === 'z') {\n                    if (points.length) {\n                        lp.push(points);\n                        points = [];\n                    }\n                    if (key === 'z') {\n                        continue;\n                    }\n                }\n                if (s.point) {\n                    points.push(s.point);\n                }\n            }\n            if (points.length) {\n                lp.push(points);\n                points = [];\n            }\n            this._linearPoints = lp;\n        }\n        return this._linearPoints;\n    }\n    get first() {\n        return this._first;\n    }\n    set first(v) {\n        this._first = v;\n    }\n    setPosition(x, y) {\n        this._position = [x, y];\n        if (!this._first) {\n            this._first = [x, y];\n        }\n    }\n    get position() {\n        return this._position;\n    }\n    get x() {\n        return this._position[0];\n    }\n    get y() {\n        return this._position[1];\n    }\n}\n// Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\nexport class RoughArcConverter {\n    constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n        this._segIndex = 0;\n        this._numSegs = 0;\n        this._rx = 0;\n        this._ry = 0;\n        this._sinPhi = 0;\n        this._cosPhi = 0;\n        this._C = [0, 0];\n        this._theta = 0;\n        this._delta = 0;\n        this._T = 0;\n        this._from = from;\n        if (from[0] === to[0] && from[1] === to[1]) {\n            return;\n        }\n        const radPerDeg = Math.PI / 180;\n        this._rx = Math.abs(radii[0]);\n        this._ry = Math.abs(radii[1]);\n        this._sinPhi = Math.sin(angle * radPerDeg);\n        this._cosPhi = Math.cos(angle * radPerDeg);\n        const x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n        const y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n        let root = 0;\n        const numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n        if (numerator < 0) {\n            const s = Math.sqrt(1 - (numerator / (this._rx * this._rx * this._ry * this._ry)));\n            this._rx = this._rx * s;\n            this._ry = this._ry * s;\n            root = 0;\n        }\n        else {\n            root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) *\n                Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n        }\n        const cxdash = root * this._rx * y1dash / this._ry;\n        const cydash = -root * this._ry * x1dash / this._rx;\n        this._C = [0, 0];\n        this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n        this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n        this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n        let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n        if ((!sweepFlag) && (dtheta > 0)) {\n            dtheta -= 2 * Math.PI;\n        }\n        else if (sweepFlag && (dtheta < 0)) {\n            dtheta += 2 * Math.PI;\n        }\n        this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n        this._delta = dtheta / this._numSegs;\n        this._T = (8 / 3) * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n    }\n    getNextSegment() {\n        if (this._segIndex === this._numSegs) {\n            return null;\n        }\n        const cosTheta1 = Math.cos(this._theta);\n        const sinTheta1 = Math.sin(this._theta);\n        const theta2 = this._theta + this._delta;\n        const cosTheta2 = Math.cos(theta2);\n        const sinTheta2 = Math.sin(theta2);\n        const to = [\n            this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0],\n            this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]\n        ];\n        const cp1 = [\n            this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1),\n            this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)\n        ];\n        const cp2 = [\n            to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2),\n            to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)\n        ];\n        this._theta = theta2;\n        this._from = [to[0], to[1]];\n        this._segIndex++;\n        return {\n            cp1: cp1,\n            cp2: cp2,\n            to: to\n        };\n    }\n    calculateVectorAngle(ux, uy, vx, vy) {\n        const ta = Math.atan2(uy, ux);\n        const tb = Math.atan2(vy, vx);\n        if (tb >= ta)\n            return tb - ta;\n        return 2 * Math.PI - (ta - tb);\n    }\n}\nexport class PathFitter {\n    constructor(sets, closed) {\n        this.sets = sets;\n        this.closed = closed;\n    }\n    fit(simplification) {\n        const outSets = [];\n        for (const set of this.sets) {\n            const length = set.length;\n            let estLength = Math.floor(simplification * length);\n            if (estLength < 5) {\n                if (length <= 5) {\n                    continue;\n                }\n                estLength = 5;\n            }\n            outSets.push(this.reduce(set, estLength));\n        }\n        let d = '';\n        for (const set of outSets) {\n            for (let i = 0; i < set.length; i++) {\n                const point = set[i];\n                if (i === 0) {\n                    d += 'M' + point[0] + ',' + point[1];\n                }\n                else {\n                    d += 'L' + point[0] + ',' + point[1];\n                }\n            }\n            if (this.closed) {\n                d += 'z ';\n            }\n        }\n        return d;\n    }\n    distance(p1, p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n    reduce(set, count) {\n        if (set.length <= count) {\n            return set;\n        }\n        const points = set.slice(0);\n        while (points.length > count) {\n            const areas = [];\n            let minArea = -1;\n            let minIndex = -1;\n            for (let i = 1; i < (points.length - 1); i++) {\n                const a = this.distance(points[i - 1], points[i]);\n                const b = this.distance(points[i], points[i + 1]);\n                const c = this.distance(points[i - 1], points[i + 1]);\n                const s = (a + b + c) / 2.0;\n                const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n                areas.push(area);\n                if ((minArea < 0) || (area < minArea)) {\n                    minArea = area;\n                    minIndex = i;\n                }\n            }\n            if (minIndex > 0) {\n                points.splice(minIndex, 1);\n            }\n            else {\n                break;\n            }\n        }\n        return points;\n    }\n}\n","export class Segment {\n    constructor(p1, p2) {\n        this.xi = Number.MAX_VALUE;\n        this.yi = Number.MAX_VALUE;\n        this.px1 = p1[0];\n        this.py1 = p1[1];\n        this.px2 = p2[0];\n        this.py2 = p2[1];\n        this.a = this.py2 - this.py1;\n        this.b = this.px1 - this.px2;\n        this.c = this.px2 * this.py1 - this.px1 * this.py2;\n        this._undefined = ((this.a === 0) && (this.b === 0) && (this.c === 0));\n    }\n    isUndefined() {\n        return this._undefined;\n    }\n    intersects(otherSegment) {\n        if (this.isUndefined() || otherSegment.isUndefined()) {\n            return false;\n        }\n        let grad1 = Number.MAX_VALUE;\n        let grad2 = Number.MAX_VALUE;\n        let int1 = 0, int2 = 0;\n        const a = this.a, b = this.b, c = this.c;\n        if (Math.abs(b) > 0.00001) {\n            grad1 = -a / b;\n            int1 = -c / b;\n        }\n        if (Math.abs(otherSegment.b) > 0.00001) {\n            grad2 = -otherSegment.a / otherSegment.b;\n            int2 = -otherSegment.c / otherSegment.b;\n        }\n        if (grad1 === Number.MAX_VALUE) {\n            if (grad2 === Number.MAX_VALUE) {\n                if ((-c / a) !== (-otherSegment.c / otherSegment.a)) {\n                    return false;\n                }\n                if ((this.py1 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px1;\n                    this.yi = this.py1;\n                    return true;\n                }\n                if ((this.py2 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py2 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px2;\n                    this.yi = this.py2;\n                    return true;\n                }\n                return false;\n            }\n            this.xi = this.px1;\n            this.yi = (grad2 * this.xi + int2);\n            if (((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) || ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(otherSegment.a) < 0.00001) {\n                if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad2 === Number.MAX_VALUE) {\n            this.xi = otherSegment.px1;\n            this.yi = grad1 * this.xi + int1;\n            if (((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) || ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(a) < 0.00001) {\n                if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad1 === grad2) {\n            if (int1 !== int2) {\n                return false;\n            }\n            if ((this.px1 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                this.xi = this.px1;\n                this.yi = this.py1;\n                return true;\n            }\n            if ((this.px2 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px2 <= Math.max(otherSegment.px1, otherSegment.px2))) {\n                this.xi = this.px2;\n                this.yi = this.py2;\n                return true;\n            }\n            return false;\n        }\n        this.xi = ((int2 - int1) / (grad1 - grad2));\n        this.yi = (grad1 * this.xi + int1);\n        if (((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) || ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001)) {\n            return false;\n        }\n        return true;\n    }\n}\n","import { Segment } from '../geometry';\nexport class HachureIterator {\n    constructor(top, bottom, left, right, gap, sinAngle, cosAngle, tanAngle) {\n        this.deltaX = 0;\n        this.hGap = 0;\n        this.top = top;\n        this.bottom = bottom;\n        this.left = left;\n        this.right = right;\n        this.gap = gap;\n        this.sinAngle = sinAngle;\n        this.tanAngle = tanAngle;\n        if (Math.abs(sinAngle) < 0.0001) {\n            this.pos = left + gap;\n        }\n        else if (Math.abs(sinAngle) > 0.9999) {\n            this.pos = top + gap;\n        }\n        else {\n            this.deltaX = (bottom - top) * Math.abs(tanAngle);\n            this.pos = left - Math.abs(this.deltaX);\n            this.hGap = Math.abs(gap / cosAngle);\n            this.sLeft = new Segment([left, bottom], [left, top]);\n            this.sRight = new Segment([right, bottom], [right, top]);\n        }\n    }\n    nextLine() {\n        if (Math.abs(this.sinAngle) < 0.0001) {\n            if (this.pos < this.right) {\n                const line = [this.pos, this.top, this.pos, this.bottom];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else if (Math.abs(this.sinAngle) > 0.9999) {\n            if (this.pos < this.bottom) {\n                const line = [this.left, this.pos, this.right, this.pos];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else {\n            let xLower = this.pos - this.deltaX / 2;\n            let xUpper = this.pos + this.deltaX / 2;\n            let yLower = this.bottom;\n            let yUpper = this.top;\n            if (this.pos < (this.right + this.deltaX)) {\n                while (((xLower < this.left) && (xUpper < this.left)) || ((xLower > this.right) && (xUpper > this.right))) {\n                    this.pos += this.hGap;\n                    xLower = this.pos - this.deltaX / 2;\n                    xUpper = this.pos + this.deltaX / 2;\n                    if (this.pos > (this.right + this.deltaX)) {\n                        return null;\n                    }\n                }\n                const s = new Segment([xLower, yLower], [xUpper, yUpper]);\n                if (this.sLeft && s.intersects(this.sLeft)) {\n                    xLower = s.xi;\n                    yLower = s.yi;\n                }\n                if (this.sRight && s.intersects(this.sRight)) {\n                    xUpper = s.xi;\n                    yUpper = s.yi;\n                }\n                if (this.tanAngle > 0) {\n                    xLower = this.right - (xLower - this.left);\n                    xUpper = this.right - (xUpper - this.left);\n                }\n                const line = [xLower, yLower, xUpper, yUpper];\n                this.pos += this.hGap;\n                return line;\n            }\n        }\n        return null;\n    }\n}\n","import { Segment } from '../geometry';\nimport { HachureIterator } from '../utils/hachure';\nexport function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getIntersectingLines(line, points) {\n    const intersections = [];\n    const s1 = new Segment([line[0], line[1]], [line[2], line[3]]);\n    for (let i = 0; i < points.length; i++) {\n        const s2 = new Segment(points[i], points[(i + 1) % points.length]);\n        if (s1.intersects(s2)) {\n            intersections.push([s1.xi, s1.yi]);\n        }\n    }\n    return intersections;\n}\nexport function affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {\n    const A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;\n    const B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;\n    const C = cosAnglePrime;\n    const D = sinAnglePrime;\n    const E = -R * sinAnglePrime;\n    const F = R * cosAnglePrime;\n    return [\n        A + C * x + D * y,\n        B + E * x + F * y\n    ];\n}\nexport function hachureLinesForPolygon(points, o) {\n    const ret = [];\n    if (points && points.length) {\n        let left = points[0][0];\n        let right = points[0][0];\n        let top = points[0][1];\n        let bottom = points[0][1];\n        for (let i = 1; i < points.length; i++) {\n            left = Math.min(left, points[i][0]);\n            right = Math.max(right, points[i][0]);\n            top = Math.min(top, points[i][1]);\n            bottom = Math.max(bottom, points[i][1]);\n        }\n        const angle = o.hachureAngle;\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const radPerDeg = Math.PI / 180;\n        const hachureAngle = (angle % 180) * radPerDeg;\n        const cosAngle = Math.cos(hachureAngle);\n        const sinAngle = Math.sin(hachureAngle);\n        const tanAngle = Math.tan(hachureAngle);\n        const it = new HachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);\n        let rect;\n        while ((rect = it.nextLine()) != null) {\n            const lines = getIntersectingLines(rect, points);\n            for (let i = 0; i < lines.length; i++) {\n                if (i < (lines.length - 1)) {\n                    const p1 = lines[i];\n                    const p2 = lines[i + 1];\n                    ret.push([p1, p2]);\n                }\n            }\n        }\n    }\n    return ret;\n}\nexport function hachureLinesForEllipse(cx, cy, width, height, o, renderer) {\n    const ret = [];\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += renderer.getOffset(-rx * 0.05, rx * 0.05, o);\n    ry += renderer.getOffset(-ry * 0.05, ry * 0.05, o);\n    const angle = o.hachureAngle;\n    let gap = o.hachureGap;\n    if (gap <= 0) {\n        gap = o.strokeWidth * 4;\n    }\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n    }\n    const radPerDeg = Math.PI / 180;\n    const hachureAngle = (angle % 180) * radPerDeg;\n    const tanAngle = Math.tan(hachureAngle);\n    const aspectRatio = ry / rx;\n    const hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);\n    const sinAnglePrime = aspectRatio * tanAngle / hyp;\n    const cosAnglePrime = 1 / hyp;\n    const gapPrime = gap / ((rx * ry / Math.sqrt((ry * cosAnglePrime) * (ry * cosAnglePrime) + (rx * sinAnglePrime) * (rx * sinAnglePrime))) / rx);\n    let halfLen = Math.sqrt((rx * rx) - (cx - rx + gapPrime) * (cx - rx + gapPrime));\n    for (let xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {\n        halfLen = Math.sqrt((rx * rx) - (cx - xPos) * (cx - xPos));\n        const p1 = affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        const p2 = affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        ret.push([p1, p2]);\n    }\n    return ret;\n}\n","import { hachureLinesForPolygon, hachureLinesForEllipse } from './filler-utils';\nexport class HachureFiller {\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        return this._fillEllipse(cx, cy, width, height, o);\n    }\n    _fillPolygon(points, o, connectEnds = false) {\n        const lines = hachureLinesForPolygon(points, o);\n        const ops = this.renderLines(lines, o, connectEnds);\n        return { type: 'fillSketch', ops };\n    }\n    _fillEllipse(cx, cy, width, height, o, connectEnds = false) {\n        const lines = hachureLinesForEllipse(cx, cy, width, height, o, this.renderer);\n        const ops = this.renderLines(lines, o, connectEnds);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o, connectEnds) {\n        let ops = [];\n        let prevPoint = null;\n        for (const line of lines) {\n            ops = ops.concat(this.renderer.doubleLine(line[0][0], line[0][1], line[1][0], line[1][1], o));\n            if (connectEnds && prevPoint) {\n                ops = ops.concat(this.renderer.doubleLine(prevPoint[0], prevPoint[1], line[0][0], line[0][1], o));\n            }\n            prevPoint = line[1];\n        }\n        return ops;\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o, true);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        return this._fillEllipse(cx, cy, width, height, o, true);\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        const set = this._fillPolygon(points, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygon(points, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        const set = this._fillEllipse(cx, cy, width, height, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillEllipse(cx, cy, width, height, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n","import { hachureLinesForPolygon, hachureLinesForEllipse, lineLength } from './filler-utils';\nexport class DotFiller {\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n    fillPolygon(points, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0 });\n        const lines = hachureLinesForPolygon(points, o);\n        return this.dotsOnLines(lines, o);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0 });\n        const lines = hachureLinesForEllipse(cx, cy, width, height, o, this.renderer);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        let ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const alpha = Math.atan((line[1][1] - line[0][1]) / (line[1][0] - line[0][0]));\n            for (let i = 0; i < count; i++) {\n                const l = gap * (i + 1);\n                const dy = l * Math.sin(alpha);\n                const dx = l * Math.cos(alpha);\n                const c = [line[0][0] - dx, line[0][1] + dy];\n                const cx = this.renderer.getOffset(c[0] - gap / 4, c[0] + gap / 4, o);\n                const cy = this.renderer.getOffset(c[1] - gap / 4, c[1] + gap / 4, o);\n                const ellipse = this.renderer.ellipse(cx, cy, fweight, fweight, o);\n                ops = ops.concat(ellipse.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nconst fillers = {};\nexport function getFiller(renderer, o) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(renderer);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(renderer);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(renderer);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(renderer);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n","import { RoughPath, RoughArcConverter, PathFitter } from './path.js';\nimport { getFiller } from './fillers/filler';\nexport class RoughRenderer {\n    line(x1, y1, x2, y2, o) {\n        const ops = this.doubleLine(x1, y1, x2, y2, o);\n        return { type: 'path', ops };\n    }\n    linearPath(points, close, o) {\n        const len = (points || []).length;\n        if (len > 2) {\n            let ops = [];\n            for (let i = 0; i < (len - 1); i++) {\n                ops = ops.concat(this.doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n            }\n            if (close) {\n                ops = ops.concat(this.doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n            }\n            return { type: 'path', ops };\n        }\n        else if (len === 2) {\n            return this.line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n        }\n        return { type: 'path', ops: [] };\n    }\n    polygon(points, o) {\n        return this.linearPath(points, true, o);\n    }\n    rectangle(x, y, width, height, o) {\n        const points = [\n            [x, y], [x + width, y], [x + width, y + height], [x, y + height]\n        ];\n        return this.polygon(points, o);\n    }\n    curve(points, o) {\n        const o1 = this._curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n        const o2 = this._curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    ellipse(x, y, width, height, o) {\n        const increment = (Math.PI * 2) / o.curveStepCount;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.05, rx * 0.05, o);\n        ry += this.getOffset(-ry * 0.05, ry * 0.05, o);\n        const o1 = this._ellipse(increment, x, y, rx, ry, 1, increment * this.getOffset(0.1, this.getOffset(0.4, 1, o), o), o);\n        const o2 = this._ellipse(increment, x, y, rx, ry, 1.5, 0, o);\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n        const cx = x;\n        const cy = y;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.01, rx * 0.01, o);\n        ry += this.getOffset(-ry * 0.01, ry * 0.01, o);\n        let strt = start;\n        let stp = stop;\n        while (strt < 0) {\n            strt += Math.PI * 2;\n            stp += Math.PI * 2;\n        }\n        if ((stp - strt) > (Math.PI * 2)) {\n            strt = 0;\n            stp = Math.PI * 2;\n        }\n        const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n        const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n        const o1 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n        const o2 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        let ops = o1.concat(o2);\n        if (closed) {\n            if (roughClosure) {\n                ops = ops.concat(this.doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));\n                ops = ops.concat(this.doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n            }\n            else {\n                ops.push({ op: 'lineTo', data: [cx, cy] });\n                ops.push({ op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n            }\n        }\n        return { type: 'path', ops };\n    }\n    svgPath(path, o) {\n        path = (path || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        let p = new RoughPath(path);\n        if (o.simplification) {\n            const fitter = new PathFitter(p.linearPoints, p.closed);\n            const d = fitter.fit(o.simplification);\n            p = new RoughPath(d);\n        }\n        let ops = [];\n        const segments = p.segments || [];\n        for (let i = 0; i < segments.length; i++) {\n            const s = segments[i];\n            const prev = i > 0 ? segments[i - 1] : null;\n            const opList = this._processSegment(p, s, prev, o);\n            if (opList && opList.length) {\n                ops = ops.concat(opList);\n            }\n        }\n        return { type: 'path', ops };\n    }\n    solidFillPolygon(points, o) {\n        const ops = [];\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + this.getOffset(-offset, offset, o), points[0][1] + this.getOffset(-offset, offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + this.getOffset(-offset, offset, o), points[i][1] + this.getOffset(-offset, offset, o)] });\n                }\n            }\n        }\n        return { type: 'fillPath', ops };\n    }\n    patternFillPolygon(points, o) {\n        const filler = getFiller(this, o);\n        return filler.fillPolygon(points, o);\n    }\n    patternFillEllipse(cx, cy, width, height, o) {\n        const filler = getFiller(this, o);\n        return filler.fillEllipse(cx, cy, width, height, o);\n    }\n    patternFillArc(x, y, width, height, start, stop, o) {\n        const cx = x;\n        const cy = y;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.01, rx * 0.01, o);\n        ry += this.getOffset(-ry * 0.01, ry * 0.01, o);\n        let strt = start;\n        let stp = stop;\n        while (strt < 0) {\n            strt += Math.PI * 2;\n            stp += Math.PI * 2;\n        }\n        if ((stp - strt) > (Math.PI * 2)) {\n            strt = 0;\n            stp = Math.PI * 2;\n        }\n        const increment = (stp - strt) / o.curveStepCount;\n        const points = [];\n        for (let angle = strt; angle <= stp; angle = angle + increment) {\n            points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n        }\n        points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n        points.push([cx, cy]);\n        return this.patternFillPolygon(points, o);\n    }\n    /// \n    getOffset(min, max, ops) {\n        return ops.roughness * ((Math.random() * (max - min)) + min);\n    }\n    doubleLine(x1, y1, x2, y2, o) {\n        const o1 = this._line(x1, y1, x2, y2, o, true, false);\n        const o2 = this._line(x1, y1, x2, y2, o, true, true);\n        return o1.concat(o2);\n    }\n    _line(x1, y1, x2, y2, o, move, overlay) {\n        const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n        let offset = o.maxRandomnessOffset || 0;\n        if ((offset * offset * 100) > lengthSq) {\n            offset = Math.sqrt(lengthSq) / 10;\n        }\n        const halfOffset = offset / 2;\n        const divergePoint = 0.2 + Math.random() * 0.2;\n        let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n        let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n        midDispX = this.getOffset(-midDispX, midDispX, o);\n        midDispY = this.getOffset(-midDispY, midDispY, o);\n        const ops = [];\n        if (move) {\n            if (overlay) {\n                ops.push({\n                    op: 'move', data: [\n                        x1 + this.getOffset(-halfOffset, halfOffset, o),\n                        y1 + this.getOffset(-halfOffset, halfOffset, o)\n                    ]\n                });\n            }\n            else {\n                ops.push({\n                    op: 'move', data: [\n                        x1 + this.getOffset(-offset, offset, o),\n                        y1 + this.getOffset(-offset, offset, o)\n                    ]\n                });\n            }\n        }\n        if (overlay) {\n            ops.push({\n                op: 'bcurveTo', data: [\n                    midDispX + x1 + (x2 - x1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispY + y1 + (y2 - y1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispX + x1 + 2 * (x2 - x1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispY + y1 + 2 * (y2 - y1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    x2 + this.getOffset(-halfOffset, halfOffset, o),\n                    y2 + this.getOffset(-halfOffset, halfOffset, o)\n                ]\n            });\n        }\n        else {\n            ops.push({\n                op: 'bcurveTo', data: [\n                    midDispX + x1 + (x2 - x1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispY + y1 + (y2 - y1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispX + x1 + 2 * (x2 - x1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispY + y1 + 2 * (y2 - y1) * divergePoint + this.getOffset(-offset, offset, o),\n                    x2 + this.getOffset(-offset, offset, o),\n                    y2 + this.getOffset(-offset, offset, o)\n                ]\n            });\n        }\n        return ops;\n    }\n    _curve(points, closePoint, o) {\n        const len = points.length;\n        let ops = [];\n        if (len > 3) {\n            const b = [];\n            const s = 1 - o.curveTightness;\n            ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n            for (let i = 1; (i + 2) < len; i++) {\n                const cachedVertArray = points[i];\n                b[0] = [cachedVertArray[0], cachedVertArray[1]];\n                b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n                b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n                b[3] = [points[i + 1][0], points[i + 1][1]];\n                ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n            }\n            if (closePoint && closePoint.length === 2) {\n                const ro = o.maxRandomnessOffset;\n                ops.push({ op: 'lineTo', data: [closePoint[0] + this.getOffset(-ro, ro, o), closePoint[1] + +this.getOffset(-ro, ro, o)] });\n            }\n        }\n        else if (len === 3) {\n            ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n            ops.push({\n                op: 'bcurveTo', data: [\n                    points[1][0], points[1][1],\n                    points[2][0], points[2][1],\n                    points[2][0], points[2][1]\n                ]\n            });\n        }\n        else if (len === 2) {\n            ops = ops.concat(this.doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n        }\n        return ops;\n    }\n    _ellipse(increment, cx, cy, rx, ry, offset, overlap, o) {\n        const radOffset = this.getOffset(-0.5, 0.5, o) - (Math.PI / 2);\n        const points = [];\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n        ]);\n        for (let angle = radOffset; angle < (Math.PI * 2 + radOffset - 0.01); angle = angle + increment) {\n            points.push([\n                this.getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n                this.getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n            ]);\n        }\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            this.getOffset(-offset, offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)\n        ]);\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            this.getOffset(-offset, offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)\n        ]);\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)\n        ]);\n        return this._curve(points, null, o);\n    }\n    _curveWithOffset(points, offset, o) {\n        const ps = [];\n        ps.push([\n            points[0][0] + this.getOffset(-offset, offset, o),\n            points[0][1] + this.getOffset(-offset, offset, o),\n        ]);\n        ps.push([\n            points[0][0] + this.getOffset(-offset, offset, o),\n            points[0][1] + this.getOffset(-offset, offset, o),\n        ]);\n        for (let i = 1; i < points.length; i++) {\n            ps.push([\n                points[i][0] + this.getOffset(-offset, offset, o),\n                points[i][1] + this.getOffset(-offset, offset, o),\n            ]);\n            if (i === (points.length - 1)) {\n                ps.push([\n                    points[i][0] + this.getOffset(-offset, offset, o),\n                    points[i][1] + this.getOffset(-offset, offset, o),\n                ]);\n            }\n        }\n        return this._curve(ps, null, o);\n    }\n    _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n        const radOffset = strt + this.getOffset(-0.1, 0.1, o);\n        const points = [];\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n        ]);\n        for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n            points.push([\n                this.getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n                this.getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n            ]);\n        }\n        points.push([\n            cx + rx * Math.cos(stp),\n            cy + ry * Math.sin(stp)\n        ]);\n        points.push([\n            cx + rx * Math.cos(stp),\n            cy + ry * Math.sin(stp)\n        ]);\n        return this._curve(points, null, o);\n    }\n    _bezierTo(x1, y1, x2, y2, x, y, path, o) {\n        const ops = [];\n        const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];\n        let f = [0, 0];\n        for (let i = 0; i < 2; i++) {\n            if (i === 0) {\n                ops.push({ op: 'move', data: [path.x, path.y] });\n            }\n            else {\n                ops.push({ op: 'move', data: [path.x + this.getOffset(-ros[0], ros[0], o), path.y + this.getOffset(-ros[0], ros[0], o)] });\n            }\n            f = [x + this.getOffset(-ros[i], ros[i], o), y + this.getOffset(-ros[i], ros[i], o)];\n            ops.push({\n                op: 'bcurveTo', data: [\n                    x1 + this.getOffset(-ros[i], ros[i], o), y1 + this.getOffset(-ros[i], ros[i], o),\n                    x2 + this.getOffset(-ros[i], ros[i], o), y2 + this.getOffset(-ros[i], ros[i], o),\n                    f[0], f[1]\n                ]\n            });\n        }\n        path.setPosition(f[0], f[1]);\n        return ops;\n    }\n    _processSegment(path, seg, prevSeg, o) {\n        let ops = [];\n        switch (seg.key) {\n            case 'M':\n            case 'm': {\n                const delta = seg.key === 'm';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    const ro = 1 * (o.maxRandomnessOffset || 0);\n                    x = x + this.getOffset(-ro, ro, o);\n                    y = y + this.getOffset(-ro, ro, o);\n                    path.setPosition(x, y);\n                    ops.push({ op: 'move', data: [x, y] });\n                }\n                break;\n            }\n            case 'L':\n            case 'l': {\n                const delta = seg.key === 'l';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, x, y, o));\n                    path.setPosition(x, y);\n                }\n                break;\n            }\n            case 'H':\n            case 'h': {\n                const delta = seg.key === 'h';\n                if (seg.data.length) {\n                    let x = +seg.data[0];\n                    if (delta) {\n                        x += path.x;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, x, path.y, o));\n                    path.setPosition(x, path.y);\n                }\n                break;\n            }\n            case 'V':\n            case 'v': {\n                const delta = seg.key === 'v';\n                if (seg.data.length) {\n                    let y = +seg.data[0];\n                    if (delta) {\n                        y += path.y;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, path.x, y, o));\n                    path.setPosition(path.x, y);\n                }\n                break;\n            }\n            case 'Z':\n            case 'z': {\n                if (path.first) {\n                    ops = ops.concat(this.doubleLine(path.x, path.y, path.first[0], path.first[1], o));\n                    path.setPosition(path.first[0], path.first[1]);\n                    path.first = null;\n                }\n                break;\n            }\n            case 'C':\n            case 'c': {\n                const delta = seg.key === 'c';\n                if (seg.data.length >= 6) {\n                    let x1 = +seg.data[0];\n                    let y1 = +seg.data[1];\n                    let x2 = +seg.data[2];\n                    let y2 = +seg.data[3];\n                    let x = +seg.data[4];\n                    let y = +seg.data[5];\n                    if (delta) {\n                        x1 += path.x;\n                        x2 += path.x;\n                        x += path.x;\n                        y1 += path.y;\n                        y2 += path.y;\n                        y += path.y;\n                    }\n                    const ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n                    ops = ops.concat(ob);\n                    path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n                }\n                break;\n            }\n            case 'S':\n            case 's': {\n                const delta = seg.key === 's';\n                if (seg.data.length >= 4) {\n                    let x2 = +seg.data[0];\n                    let y2 = +seg.data[1];\n                    let x = +seg.data[2];\n                    let y = +seg.data[3];\n                    if (delta) {\n                        x2 += path.x;\n                        x += path.x;\n                        y2 += path.y;\n                        y += path.y;\n                    }\n                    let x1 = x2;\n                    let y1 = y2;\n                    const prevKey = prevSeg ? prevSeg.key : '';\n                    let ref = null;\n                    if (prevKey === 'c' || prevKey === 'C' || prevKey === 's' || prevKey === 'S') {\n                        ref = path.bezierReflectionPoint;\n                    }\n                    if (ref) {\n                        x1 = ref[0];\n                        y1 = ref[1];\n                    }\n                    const ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n                    ops = ops.concat(ob);\n                    path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n                }\n                break;\n            }\n            case 'Q':\n            case 'q': {\n                const delta = seg.key === 'q';\n                if (seg.data.length >= 4) {\n                    let x1 = +seg.data[0];\n                    let y1 = +seg.data[1];\n                    let x = +seg.data[2];\n                    let y = +seg.data[3];\n                    if (delta) {\n                        x1 += path.x;\n                        x += path.x;\n                        y1 += path.y;\n                        y += path.y;\n                    }\n                    const offset1 = 1 * (1 + o.roughness * 0.2);\n                    const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset1, offset1, o), path.y + this.getOffset(-offset1, offset1, o)] });\n                    let f = [x + this.getOffset(-offset1, offset1, o), y + this.getOffset(-offset1, offset1, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset1, offset1, o), y1 + this.getOffset(-offset1, offset1, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset2, offset2, o), path.y + this.getOffset(-offset2, offset2, o)] });\n                    f = [x + this.getOffset(-offset2, offset2, o), y + this.getOffset(-offset2, offset2, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset2, offset2, o), y1 + this.getOffset(-offset2, offset2, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    path.setPosition(f[0], f[1]);\n                    path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n                }\n                break;\n            }\n            case 'T':\n            case 't': {\n                const delta = seg.key === 't';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    let x1 = x;\n                    let y1 = y;\n                    const prevKey = prevSeg ? prevSeg.key : '';\n                    let ref = null;\n                    if (prevKey === 'q' || prevKey === 'Q' || prevKey === 't' || prevKey === 'T') {\n                        ref = path.quadReflectionPoint;\n                    }\n                    if (ref) {\n                        x1 = ref[0];\n                        y1 = ref[1];\n                    }\n                    const offset1 = 1 * (1 + o.roughness * 0.2);\n                    const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset1, offset1, o), path.y + this.getOffset(-offset1, offset1, o)] });\n                    let f = [x + this.getOffset(-offset1, offset1, o), y + this.getOffset(-offset1, offset1, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset1, offset1, o), y1 + this.getOffset(-offset1, offset1, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset2, offset2, o), path.y + this.getOffset(-offset2, offset2, o)] });\n                    f = [x + this.getOffset(-offset2, offset2, o), y + this.getOffset(-offset2, offset2, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset2, offset2, o), y1 + this.getOffset(-offset2, offset2, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    path.setPosition(f[0], f[1]);\n                    path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n                }\n                break;\n            }\n            case 'A':\n            case 'a': {\n                const delta = seg.key === 'a';\n                if (seg.data.length >= 7) {\n                    const rx = +seg.data[0];\n                    const ry = +seg.data[1];\n                    const angle = +seg.data[2];\n                    const largeArcFlag = +seg.data[3];\n                    const sweepFlag = +seg.data[4];\n                    let x = +seg.data[5];\n                    let y = +seg.data[6];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    if (x === path.x && y === path.y) {\n                        break;\n                    }\n                    if (rx === 0 || ry === 0) {\n                        ops = ops.concat(this.doubleLine(path.x, path.y, x, y, o));\n                        path.setPosition(x, y);\n                    }\n                    else {\n                        for (let i = 0; i < 1; i++) {\n                            const arcConverter = new RoughArcConverter([path.x, path.y], [x, y], [rx, ry], angle, largeArcFlag ? true : false, sweepFlag ? true : false);\n                            let segment = arcConverter.getNextSegment();\n                            while (segment) {\n                                const ob = this._bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);\n                                ops = ops.concat(ob);\n                                segment = arcConverter.getNextSegment();\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n            default:\n                break;\n        }\n        return ops;\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasSelf = typeof self !== 'undefined';\nconst roughScript = hasSelf && self && self.document && self.document.currentScript && self.document.currentScript.src;\nexport function createRenderer(config) {\n    if (hasSelf && roughScript && self && self.workly && config.async && (!config.noWorker)) {\n        const worklySource = config.worklyURL || 'https://cdn.jsdelivr.net/gh/pshihn/workly/dist/workly.min.js';\n        if (worklySource) {\n            const code = `importScripts('${worklySource}', '${roughScript}');\\nworkly.expose(self.rough.createRenderer());`;\n            const ourl = URL.createObjectURL(new Blob([code]));\n            return self.workly.proxy(ourl);\n        }\n    }\n    return new RoughRenderer();\n}\n","import { createRenderer } from './renderer-factory.js';\nconst hasSelf = typeof self !== 'undefined';\nexport class RoughGeneratorBase {\n    constructor(config, surface) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1\n        };\n        this.config = config || {};\n        this.surface = surface;\n        this.renderer = createRenderer(this.config);\n        if (this.config.options) {\n            this.defaultOptions = this._options(this.config.options);\n        }\n    }\n    _options(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _drawable(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    get lib() {\n        return this.renderer;\n    }\n    getCanvasSize() {\n        const val = (w) => {\n            if (w && typeof w === 'object') {\n                if (w.baseVal && w.baseVal.value) {\n                    return w.baseVal.value;\n                }\n            }\n            return w || 100;\n        };\n        if (this.surface) {\n            return [val(this.surface.width), val(this.surface.height)];\n        }\n        return [100, 100];\n    }\n    computePolygonSize(points) {\n        if (points.length) {\n            let left = points[0][0];\n            let right = points[0][0];\n            let top = points[0][1];\n            let bottom = points[0][1];\n            for (let i = 1; i < points.length; i++) {\n                left = Math.min(left, points[i][0]);\n                right = Math.max(right, points[i][0]);\n                top = Math.min(top, points[i][1]);\n                bottom = Math.max(bottom, points[i][1]);\n            }\n            return [(right - left), (bottom - top)];\n        }\n        return [0, 0];\n    }\n    polygonPath(points) {\n        let d = '';\n        if (points.length) {\n            d = `M${points[0][0]},${points[0][1]}`;\n            for (let i = 1; i < points.length; i++) {\n                d = `${d} L${points[i][0]},${points[i][1]}`;\n            }\n        }\n        return d;\n    }\n    computePathSize(d) {\n        let size = [0, 0];\n        if (hasSelf && self.document) {\n            try {\n                const ns = 'http://www.w3.org/2000/svg';\n                const svg = self.document.createElementNS(ns, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(ns, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                self.document.body.appendChild(svg);\n                const bb = pathNode.getBBox();\n                if (bb) {\n                    size[0] = bb.width || 0;\n                    size[1] = bb.height || 0;\n                }\n                self.document.body.removeChild(svg);\n            }\n            catch (err) { }\n        }\n        const canvasSize = this.getCanvasSize();\n        if (!(size[0] * size[1])) {\n            size = canvasSize;\n        }\n        return size;\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: 'none'\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        fill: o.fill || 'none'\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n                case 'path2Dfill':\n                    path = {\n                        d: drawing.path || '',\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        fill: o.fill || 'none'\n                    };\n                    break;\n                case 'path2Dpattern': {\n                    const size = drawing.size;\n                    const pattern = {\n                        x: 0, y: 0, width: 1, height: 1,\n                        viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n                        patternUnits: 'objectBoundingBox',\n                        path: this.fillSketch(drawing, o)\n                    };\n                    path = {\n                        d: drawing.path,\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        pattern: pattern\n                    };\n                    break;\n                }\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || 'none',\n            strokeWidth: fweight,\n            fill: 'none'\n        };\n    }\n    opsToPath(drawing) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'qcurveTo':\n                    path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n}\n","import { RoughGeneratorBase } from './generator-base';\nexport class RoughGenerator extends RoughGeneratorBase {\n    constructor(config, surface) {\n        super(config, surface);\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [this.lib.line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(this.lib.patternFillPolygon(points, o));\n            }\n        }\n        paths.push(this.lib.rectangle(x, y, width, height, o));\n        return this._drawable('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = this.lib.ellipse(x, y, width, height, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(this.lib.patternFillEllipse(x, y, width, height, o));\n            }\n        }\n        paths.push(this.lib.ellipse(x, y, width, height, o));\n        return this._drawable('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [this.lib.linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = this.lib.arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(this.lib.patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        paths.push(this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n        return this._drawable('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [this.lib.curve(points, o)], o);\n    }\n    polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                const size = this.computePolygonSize(points);\n                const fillPoints = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = this.lib.patternFillPolygon(fillPoints, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = this.polygonPath(points);\n                paths.push(shape);\n            }\n        }\n        paths.push(this.lib.linearPath(points, true, o));\n        return this._drawable('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = this.lib.patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        paths.push(this.lib.svgPath(d, o));\n        return this._drawable('path', paths, o);\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughCanvasBase {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n    }\n    static createRenderer() {\n        return new RoughRenderer();\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillPath':\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n                case 'path2Dfill': {\n                    this.ctx.save();\n                    this.ctx.fillStyle = o.fill || '';\n                    const p2d = new Path2D(drawing.path);\n                    this.ctx.fill(p2d);\n                    this.ctx.restore();\n                    break;\n                }\n                case 'path2Dpattern': {\n                    const doc = this.canvas.ownerDocument || (hasDocument && document);\n                    if (doc) {\n                        const size = drawing.size;\n                        const hcanvas = doc.createElement('canvas');\n                        const hcontext = hcanvas.getContext('2d');\n                        const bbox = this.computeBBox(drawing.path);\n                        if (bbox && (bbox.width || bbox.height)) {\n                            hcanvas.width = this.canvas.width;\n                            hcanvas.height = this.canvas.height;\n                            hcontext.translate(bbox.x || 0, bbox.y || 0);\n                        }\n                        else {\n                            hcanvas.width = size[0];\n                            hcanvas.height = size[1];\n                        }\n                        this.fillSketch(hcontext, drawing, o);\n                        this.ctx.save();\n                        this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n                        const p2d = new Path2D(drawing.path);\n                        this.ctx.fill(p2d);\n                        this.ctx.restore();\n                    }\n                    else {\n                        console.error('Cannot render path2Dpattern. No defs/document defined.');\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    computeBBox(d) {\n        if (hasDocument) {\n            try {\n                const ns = 'http://www.w3.org/2000/svg';\n                const svg = document.createElementNS(ns, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(ns, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                document.body.appendChild(svg);\n                const bbox = pathNode.getBBox();\n                document.body.removeChild(svg);\n                return bbox;\n            }\n            catch (err) { }\n        }\n        return null;\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing) {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'qcurveTo':\n                    ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill();\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n}\n","import { RoughGenerator } from './generator';\nimport { RoughCanvasBase } from './canvas-base';\nexport class RoughCanvas extends RoughCanvasBase {\n    constructor(canvas, config) {\n        super(canvas);\n        this.gen = new RoughGenerator(config || null, this.canvas);\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","import { RoughGeneratorBase } from './generator-base';\nexport class RoughGeneratorAsync extends RoughGeneratorBase {\n    async line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [await this.lib.line(x1, y1, x2, y2, o)], o);\n    }\n    async rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(await this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(await this.lib.patternFillPolygon(points, o));\n            }\n        }\n        paths.push(await this.lib.rectangle(x, y, width, height, o));\n        return this._drawable('rectangle', paths, o);\n    }\n    async ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = await this.lib.ellipse(x, y, width, height, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(await this.lib.patternFillEllipse(x, y, width, height, o));\n            }\n        }\n        paths.push(await this.lib.ellipse(x, y, width, height, o));\n        return this._drawable('ellipse', paths, o);\n    }\n    async circle(x, y, diameter, options) {\n        const ret = await this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    async linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [await this.lib.linearPath(points, false, o)], o);\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = await this.lib.arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(await this.lib.patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        paths.push(await this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n        return this._drawable('arc', paths, o);\n    }\n    async curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [await this.lib.curve(points, o)], o);\n    }\n    async polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(await this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                const size = this.computePolygonSize(points);\n                const fillPoints = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = await this.lib.patternFillPolygon(fillPoints, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = this.polygonPath(points);\n                paths.push(shape);\n            }\n        }\n        paths.push(await this.lib.linearPath(points, true, o));\n        return this._drawable('polygon', paths, o);\n    }\n    async path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = await this.lib.patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        paths.push(await this.lib.svgPath(d, o));\n        return this._drawable('path', paths, o);\n    }\n}\n","import { RoughGeneratorAsync } from './generator-async';\nimport { RoughCanvasBase } from './canvas-base';\nexport class RoughCanvasAsync extends RoughCanvasBase {\n    constructor(canvas, config) {\n        super(canvas);\n        this.genAsync = new RoughGeneratorAsync(config || null, this.canvas);\n    }\n    get generator() {\n        return this.genAsync;\n    }\n    getDefaultOptions() {\n        return this.genAsync.defaultOptions;\n    }\n    async line(x1, y1, x2, y2, options) {\n        const d = await this.genAsync.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    async rectangle(x, y, width, height, options) {\n        const d = await this.genAsync.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    async ellipse(x, y, width, height, options) {\n        const d = await this.genAsync.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    async circle(x, y, diameter, options) {\n        const d = await this.genAsync.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    async linearPath(points, options) {\n        const d = await this.genAsync.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    async polygon(points, options) {\n        const d = await this.genAsync.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = await this.genAsync.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    async curve(points, options) {\n        const d = await this.genAsync.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    async path(d, options) {\n        const drawing = await this.genAsync.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","import { RoughCanvas } from './canvas';\nimport { RoughGenerator } from './generator';\nimport { RoughGeneratorAsync } from './generator-async';\nimport { RoughCanvasAsync } from './canvas-async';\nimport { RoughSVG } from './svg';\nimport { RoughSVGAsync } from './svg-async';\nexport default {\n    canvas(canvas, config) {\n        if (config && config.async) {\n            return new RoughCanvasAsync(canvas, config);\n        }\n        return new RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        if (config && config.async) {\n            return new RoughSVGAsync(svg, config);\n        }\n        return new RoughSVG(svg, config);\n    },\n    createRenderer() {\n        return RoughCanvas.createRenderer();\n    },\n    generator(config, surface) {\n        if (config && config.async) {\n            return new RoughGeneratorAsync(config, surface);\n        }\n        return new RoughGenerator(config, surface);\n    }\n};\n","/**\n * Copyright 2014 Google Inc. All rights reserved.\n *\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n *\n * @fileoverview Description of this file.\n *\n * A polyfill for HTML Canvas features, including\n * Path2D support.\n */\n\n(function (CanvasRenderingContext2D, nodeRequire) {\n\nif (CanvasRenderingContext2D == undefined) {\n  CanvasRenderingContext2D = nodeRequire('canvas').Context2d;\n}\n\nif (CanvasRenderingContext2D.prototype.ellipse == undefined) {\n  CanvasRenderingContext2D.prototype.ellipse = function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n    this.save();\n    this.translate(x, y);\n    this.rotate(rotation);\n    this.scale(radiusX, radiusY);\n    this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n    this.restore();\n  }\n}\n\nif (typeof Path2D !== 'function' || \n    typeof new Path2D().addPath !== 'function') {\n  (function() {\n\n    // Include the SVG path parser.\n    parser = (function() {\n      /*\n       * Generated by PEG.js 0.8.0.\n       *\n       * http://pegjs.majda.cz/\n       */\n    \n      function peg$subclass(child, parent) {\n        function ctor() { this.constructor = child; }\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n    \n      function SyntaxError(message, expected, found, offset, line, column) {\n        this.message  = message;\n        this.expected = expected;\n        this.found    = found;\n        this.offset   = offset;\n        this.line     = line;\n        this.column   = column;\n    \n        this.name     = \"SyntaxError\";\n      }\n    \n      peg$subclass(SyntaxError, Error);\n    \n      function parse(input) {\n        var options = arguments.length > 1 ? arguments[1] : {},\n    \n            peg$FAILED = {},\n    \n            peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n            peg$startRuleFunction  = peg$parsesvg_path,\n    \n            peg$c0 = peg$FAILED,\n            peg$c1 = [],\n            peg$c2 = null,\n            peg$c3 = function(d) { return ops; },\n            peg$c4 = /^[Mm]/,\n            peg$c5 = { type: \"class\", value: \"[Mm]\", description: \"[Mm]\" },\n            peg$c6 = function(ch, args) {\n                  var moveCh = ch\n                  // If this is the first move cmd then force it to be absolute.\n                  if (firstSubPath) {\n                    moveCh = 'M';\n                    firstSubPath = false;\n                  }\n                  ops.push({type: 'moveTo', args: makeAbsolute(moveCh, args[0])});\n                  for (var i=1; i < args.length; i++) {\n                    // The lineTo args are either abs or relative, depending on the\n                    // original moveto command.\n                    ops.push({type: 'lineTo', args: makeAbsolute(ch, args[i])});\n                  }\n                },\n            peg$c7 = function(one, rest) { return concatSequence(one, rest); },\n            peg$c8 = /^[Zz]/,\n            peg$c9 = { type: \"class\", value: \"[Zz]\", description: \"[Zz]\" },\n            peg$c10 = function() { ops.push({type: 'closePath', args: []}); },\n            peg$c11 = /^[Ll]/,\n            peg$c12 = { type: \"class\", value: \"[Ll]\", description: \"[Ll]\" },\n            peg$c13 = function(ch, args) {\n                  for (var i=0; i < args.length; i++) {\n                    ops.push({type: 'lineTo', args: makeAbsolute(ch, args[i])});\n                  }\n                },\n            peg$c14 = /^[Hh]/,\n            peg$c15 = { type: \"class\", value: \"[Hh]\", description: \"[Hh]\" },\n            peg$c16 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'lineTo', args: makeAbsoluteFromX(ch, args[i])});\n                }\n              },\n            peg$c17 = /^[Vv]/,\n            peg$c18 = { type: \"class\", value: \"[Vv]\", description: \"[Vv]\" },\n            peg$c19 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'lineTo', args: makeAbsoluteFromY(ch, args[i])});\n                }\n              },\n            peg$c20 = /^[Cc]/,\n            peg$c21 = { type: \"class\", value: \"[Cc]\", description: \"[Cc]\" },\n            peg$c22 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'bezierCurveTo', args: makeAbsoluteMultiple(ch, args[i])});\n                }\n              },\n            peg$c23 = function(cp1, cp2, last) { return cp1.concat(cp2, last); },\n            peg$c24 = /^[Ss]/,\n            peg$c25 = { type: \"class\", value: \"[Ss]\", description: \"[Ss]\" },\n            peg$c26 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'bezierCurveTo', args: makeReflected().concat(makeAbsoluteMultiple(ch, args[i]))});\n                }\n              },\n            peg$c27 = function(cp1, last) { return cp1.concat(last); },\n            peg$c28 = /^[Qq]/,\n            peg$c29 = { type: \"class\", value: \"[Qq]\", description: \"[Qq]\" },\n            peg$c30 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'quadraticCurveTo', args: makeAbsoluteMultiple(ch, args[i])});\n                }\n              },\n            peg$c31 = /^[Tt]/,\n            peg$c32 = { type: \"class\", value: \"[Tt]\", description: \"[Tt]\" },\n            peg$c33 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  var reflected = makeReflected();\n                  ops.push({type: 'quadraticCurveTo', args: reflected.concat(makeAbsoluteMultiple(ch, args[i]))});\n                  lastControl = reflected.slice(0);\n                }\n              },\n            peg$c34 = /^[Aa]/,\n            peg$c35 = { type: \"class\", value: \"[Aa]\", description: \"[Aa]\" },\n            peg$c36 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  var x1 = [lastCoord.slice()];\n                  var x2 = [makeAbsolute(ch, args[i].slice(-2))];\n                  absArgs = x1.concat(args[i].slice(0, -2), x2);\n                  ellipseFromEllipticalArc.apply(this, absArgs);\n                }\n              },\n            peg$c37 = function(rx, ry, xrot, large, sweep, last) { return [parseFloat(rx), parseFloat(ry), parseFloat(flatten(xrot).join('')), parseInt(large), parseInt(sweep), last[0], last[1]]; },\n            peg$c38 = function(x, y) { return [x, y] },\n            peg$c39 = function(number) { return parseFloat(flatten(number).join('')) },\n            peg$c40 = \"0\",\n            peg$c41 = { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n            peg$c42 = \"1\",\n            peg$c43 = { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n            peg$c44 = \",\",\n            peg$c45 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n            peg$c46 = \".\",\n            peg$c47 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n            peg$c48 = /^[eE]/,\n            peg$c49 = { type: \"class\", value: \"[eE]\", description: \"[eE]\" },\n            peg$c50 = \"+\",\n            peg$c51 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n            peg$c52 = \"-\",\n            peg$c53 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n            peg$c54 = /^[0-9]/,\n            peg$c55 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n            peg$c56 = function(digits) { return digits.join('') },\n            peg$c57 = /^[ \\t\\n\\r]/,\n            peg$c58 = { type: \"class\", value: \"[ \\\\t\\\\n\\\\r]\", description: \"[ \\\\t\\\\n\\\\r]\" },\n    \n            peg$currPos          = 0,\n            peg$reportedPos      = 0,\n            peg$cachedPos        = 0,\n            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n            peg$maxFailPos       = 0,\n            peg$maxFailExpected  = [],\n            peg$silentFails      = 0,\n    \n            peg$result;\n    \n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n    \n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n    \n        function text() {\n          return input.substring(peg$reportedPos, peg$currPos);\n        }\n    \n        function offset() {\n          return peg$reportedPos;\n        }\n    \n        function line() {\n          return peg$computePosDetails(peg$reportedPos).line;\n        }\n    \n        function column() {\n          return peg$computePosDetails(peg$reportedPos).column;\n        }\n    \n        function expected(description) {\n          throw peg$buildException(\n            null,\n            [{ type: \"other\", description: description }],\n            peg$reportedPos\n          );\n        }\n    \n        function error(message) {\n          throw peg$buildException(message, null, peg$reportedPos);\n        }\n    \n        function peg$computePosDetails(pos) {\n          function advance(details, startPos, endPos) {\n            var p, ch;\n    \n            for (p = startPos; p < endPos; p++) {\n              ch = input.charAt(p);\n              if (ch === \"\\n\") {\n                if (!details.seenCR) { details.line++; }\n                details.column = 1;\n                details.seenCR = false;\n              } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n                details.line++;\n                details.column = 1;\n                details.seenCR = true;\n              } else {\n                details.column++;\n                details.seenCR = false;\n              }\n            }\n          }\n    \n          if (peg$cachedPos !== pos) {\n            if (peg$cachedPos > pos) {\n              peg$cachedPos = 0;\n              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n            }\n            advance(peg$cachedPosDetails, peg$cachedPos, pos);\n            peg$cachedPos = pos;\n          }\n    \n          return peg$cachedPosDetails;\n        }\n    \n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) { return; }\n    \n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n    \n          peg$maxFailExpected.push(expected);\n        }\n    \n        function peg$buildException(message, expected, pos) {\n          function cleanupExpected(expected) {\n            var i = 1;\n    \n            expected.sort(function(a, b) {\n              if (a.description < b.description) {\n                return -1;\n              } else if (a.description > b.description) {\n                return 1;\n              } else {\n                return 0;\n              }\n            });\n    \n            while (i < expected.length) {\n              if (expected[i - 1] === expected[i]) {\n                expected.splice(i, 1);\n              } else {\n                i++;\n              }\n            }\n          }\n    \n          function buildMessage(expected, found) {\n            function stringEscape(s) {\n              function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n    \n              return s\n                .replace(/\\\\/g,   '\\\\\\\\')\n                .replace(/\"/g,    '\\\\\"')\n                .replace(/\\x08/g, '\\\\b')\n                .replace(/\\t/g,   '\\\\t')\n                .replace(/\\n/g,   '\\\\n')\n                .replace(/\\f/g,   '\\\\f')\n                .replace(/\\r/g,   '\\\\r')\n                .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n                .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n                .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n                .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n            }\n    \n            var expectedDescs = new Array(expected.length),\n                expectedDesc, foundDesc, i;\n    \n            for (i = 0; i < expected.length; i++) {\n              expectedDescs[i] = expected[i].description;\n            }\n    \n            expectedDesc = expected.length > 1\n              ? expectedDescs.slice(0, -1).join(\", \")\n                  + \" or \"\n                  + expectedDescs[expected.length - 1]\n              : expectedDescs[0];\n    \n            foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n    \n            return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n          }\n    \n          var posDetails = peg$computePosDetails(pos),\n              found      = pos < input.length ? input.charAt(pos) : null;\n    \n          if (expected !== null) {\n            cleanupExpected(expected);\n          }\n    \n          return new SyntaxError(\n            message !== null ? message : buildMessage(expected, found),\n            expected,\n            found,\n            pos,\n            posDetails.line,\n            posDetails.column\n          );\n        }\n    \n        function peg$parsesvg_path() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewsp();\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsewsp();\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsemoveTo_drawTo_commandGroups();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsewsp();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsewsp();\n              }\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c3(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveTo_drawTo_commandGroups() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parsewsp();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsewsp();\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsemoveTo_drawTo_commandGroups();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveTo_drawTo_commandGroup() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsemoveto();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parsewsp();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsewsp();\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsedrawto_commands();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsedrawto_commands() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsedrawto_command();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parsewsp();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsewsp();\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsedrawto_commands();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsedrawto_command() {\n          var s0;\n    \n          s0 = peg$parseclosepath();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parselineto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsehorizontal_lineto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsevertical_lineto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsecurveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsesmooth_curveto();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsequadratic_bezier_curveto();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parseelliptical_arc();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsemoveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c6(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parselineto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseclosepath() {\n          var s0, s1;\n    \n          s0 = peg$currPos;\n          if (peg$c8.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c9); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c10();\n          }\n          s0 = s1;\n    \n          return s0;\n        }\n    \n        function peg$parselineto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c11.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c12); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parselineto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c13(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parselineto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parselineto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsehorizontal_lineto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c14.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c16(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecoordinate_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsecoordinate_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsevertical_lineto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c19(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecurveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecurveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c22(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecurveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecurveto_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsecurveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecurveto_argument() {\n          var s0, s1, s2, s3, s4, s5;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_pair();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parsecomma_wsp();\n                if (s4 === peg$FAILED) {\n                  s4 = peg$c2;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsecoordinate_pair();\n                  if (s5 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c23(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_curveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c24.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c25); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsesmooth_curveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c26(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_curveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsesmooth_curveto_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsesmooth_curveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_curveto_argument() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_pair();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c27(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsequadratic_bezier_curveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c28.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c30(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsequadratic_bezier_curveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsequadratic_bezier_curveto_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsequadratic_bezier_curveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsequadratic_bezier_curveto_argument() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_pair();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c27(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_quadratic_bezier_curveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c31.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c33(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseelliptical_arc() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c34.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c35); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseelliptical_arc_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c36(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseelliptical_arc_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parseelliptical_arc_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseelliptical_arc_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseelliptical_arc_argument() {\n          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsenonnegative_number();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsenonnegative_number();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parsecomma_wsp();\n                if (s4 === peg$FAILED) {\n                  s4 = peg$c2;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsecomma_wsp();\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parseflag();\n                      if (s7 !== peg$FAILED) {\n                        s8 = peg$parsecomma_wsp();\n                        if (s8 === peg$FAILED) {\n                          s8 = peg$c2;\n                        }\n                        if (s8 !== peg$FAILED) {\n                          s9 = peg$parseflag();\n                          if (s9 !== peg$FAILED) {\n                            s10 = peg$parsecomma_wsp();\n                            if (s10 === peg$FAILED) {\n                              s10 = peg$c2;\n                            }\n                            if (s10 !== peg$FAILED) {\n                              s11 = peg$parsecoordinate_pair();\n                              if (s11 !== peg$FAILED) {\n                                peg$reportedPos = s0;\n                                s1 = peg$c37(s1, s3, s5, s7, s9, s11);\n                                s0 = s1;\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$c0;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecoordinate_pair() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c38(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecoordinate() {\n          var s0, s1;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsenumber();\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c39(s1);\n          }\n          s0 = s1;\n    \n          return s0;\n        }\n    \n        function peg$parsenonnegative_number() {\n          var s0;\n    \n          s0 = peg$parsefloating_point_constant();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsedigit_sequence();\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsenumber() {\n          var s0, s1, s2;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsesign();\n          if (s1 === peg$FAILED) {\n            s1 = peg$c2;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsefloating_point_constant();\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsesign();\n            if (s1 === peg$FAILED) {\n              s1 = peg$c2;\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsedigit_sequence();\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseflag() {\n          var s0;\n    \n          if (input.charCodeAt(peg$currPos) === 48) {\n            s0 = peg$c40;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c41); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 49) {\n              s0 = peg$c42;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecomma_wsp() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewsp();\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsewsp();\n            }\n          } else {\n            s1 = peg$c0;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsewsp();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsewsp();\n              }\n              if (s3 !== peg$FAILED) {\n                s1 = [s1, s2, s3];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecomma();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$parsewsp();\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parsewsp();\n              }\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecomma() {\n          var s0;\n    \n          if (input.charCodeAt(peg$currPos) === 44) {\n            s0 = peg$c44;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c45); }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsefloating_point_constant() {\n          var s0, s1, s2;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsefractional_constant();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseexponent();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsedigit_sequence();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseexponent();\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsefractional_constant() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsedigit_sequence();\n          if (s1 === peg$FAILED) {\n            s1 = peg$c2;\n          }\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s2 = peg$c46;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c47); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsedigit_sequence();\n              if (s3 !== peg$FAILED) {\n                s1 = [s1, s2, s3];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsedigit_sequence();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s2 = peg$c46;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c47); }\n              }\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseexponent() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c48.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsesign();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsedigit_sequence();\n              if (s3 !== peg$FAILED) {\n                s1 = [s1, s2, s3];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesign() {\n          var s0;\n    \n          if (input.charCodeAt(peg$currPos) === 43) {\n            s0 = peg$c50;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s0 = peg$c52;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsedigit_sequence() {\n          var s0, s1, s2;\n    \n          s0 = peg$currPos;\n          s1 = [];\n          if (peg$c54.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c55); }\n          }\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              if (peg$c54.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c55); }\n              }\n            }\n          } else {\n            s1 = peg$c0;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c56(s1);\n          }\n          s0 = s1;\n    \n          return s0;\n        }\n    \n        function peg$parsewsp() {\n          var s0;\n    \n          if (peg$c57.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c58); }\n          }\n    \n          return s0;\n        }\n    \n    \n          // The last coordinate we are at in the path. In absolute coords.\n          var lastCoord = [0, 0];\n          // The last control point we encountered in the path. In absolute coords.\n          var lastControl = [0, 0];\n          // The list of operations we've parsed so far.\n          var ops = [];\n          // Have we parsed the first sub-path yet?\n          var firstSubPath = true;\n          // The letter of the last parsed command.\n          var lastCh = '';\n    \n          // Flatten an array.\n          function flatten(a) {\n            var flat = [];\n            for (var i = 0; i < a.length; i++) {\n              if (a[i] instanceof Array) {\n                flat.push.apply(flat, flatten(a[i]));\n              } else {\n                flat.push(a[i]);\n              }\n            }\n            return flat;\n          }\n    \n          // Convert a position into an absolute position.\n          function makeAbsolute(c, coord) {\n            if ('mlazhvcsqt'.indexOf(c) === -1) {\n              lastCoord = coord;\n            } else {\n              lastCoord[0] += coord[0];\n              lastCoord[1] += coord[1];\n            }\n            lastCh = c;\n            return lastCoord.slice(0);\n          }\n    \n          // Convert a sequence of coordinates into absolute coordinates.\n          //\n          // For arguments that take multiple coord pairs, such as bezier.\n          function makeAbsoluteMultiple(c, seq) {\n            var r = [];\n            var lastPosCopy = lastCoord.slice(0);\n            for (var i=0; i < seq.length; i+=2) {\n              // Only the last point should update lastCoord.\n              lastCoord = lastPosCopy.slice(0);\n              var coord = makeAbsolute(c, seq.slice(i, i+2));\n              r = r.concat(coord);\n              // Record the last control point, it might be needed for\n              // shorthand operations.\n              if (i == seq.length-4) {\n                lastControl = coord.slice(0);\n              }\n            }\n            return r;\n          }\n    \n          // Find the reflection of the last control point over\n          // the last postion in the path.\n          function makeReflected() {\n            if ('CcSsQqTt'.indexOf(lastCh) == -1) {\n              lastControl = lastCoord.slice(0);\n            }\n            // reflected = 2*lastCoord - lastControl\n            // Note the result is absolute, not relative.\n            var r = [0, 0];\n            r[0] = 2*lastCoord[0] - lastControl[0];\n            r[1] = 2*lastCoord[1] - lastControl[1];\n            return r;\n          }\n    \n          function makeAbsoluteFromX(c, x) {\n            var coord = [x, 0];\n            if (c == 'H') {\n              coord[1] = lastCoord[1];\n            }\n            return makeAbsolute(c, coord);\n          }\n    \n          function makeAbsoluteFromY(c, y) {\n            var coord = [0, y];\n            if (c == 'V') {\n              coord[0] = lastCoord[0];\n            }\n            return makeAbsolute(c, coord);\n          }\n    \n          function concatSequence(one, rest) {\n            var r = [one];\n            if (rest && rest.length > 1) {\n              var rem = rest[1];\n              for (var i = 0; i < rem.length; i++) {\n                r.push(rem[i]);\n              }\n            }\n            return r;\n          }\n    \n          function mag(v) {\n            return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n          }\n    \n          function dot(u, v) {\n            return (u[0]*v[0] + u[1]*v[1]);\n          }\n    \n          function ratio(u, v) {\n            return dot(u,v) / (mag(u)*mag(v))\n          }\n\n          function clamp(value, min, max) {\n            return Math.min(Math.max(val, min),max);\n          }\n    \n          function angle(u, v) {\n            var sign = 1.0;\n            if ((u[0]*v[1] - u[1]*v[0]) < 0) {\n              sign = -1.0;\n            }\n            return sign * Math.acos(clamp(ratio(u,v)), -1, 1);\n          }\n    \n          function rotClockwise(v, angle) {\n            var cost = Math.cos(angle);\n            var sint = Math.sin(angle);\n            return [cost*v[0] + sint*v[1], -1 * sint*v[0] + cost*v[1]];\n          }\n    \n          function rotCounterClockwise(v, angle) {\n            var cost = Math.cos(angle);\n            var sint = Math.sin(angle);\n            return [cost*v[0] - sint*v[1], sint*v[0] + cost*v[1]];\n          }\n    \n          function midPoint(u, v) {\n            return [(u[0] - v[0])/2.0, (u[1] - v[1])/2.0];\n          }\n    \n          function meanVec(u, v) {\n            return [(u[0] + v[0])/2.0, (u[1] + v[1])/2.0];\n          }\n    \n          function pointMul(u, v) {\n            return [u[0]*v[0], u[1]*v[1]];\n          }\n    \n          function scale(c, v) {\n            return [c*v[0], c*v[1]];\n          }\n    \n          function sum(u, v) {\n            return [u[0] + v[0], u[1] + v[1]];\n          }\n    \n          // Convert an SVG elliptical arc to a series of canvas commands.\n          //\n          // x1, x2: start and stop coordinates of the ellipse.\n          // rx, ry: radii of the ellipse.\n          // phi: rotation of the ellipse.\n          // fA: large arc flag.\n          // fS: sweep flag.\n          function ellipseFromEllipticalArc(x1, rx, ry, phi, fA, fS, x2) {\n            // Convert from endpoint to center parametrization, as detailed in:\n            //   http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n            if (rx == 0 || ry == 0) {\n              ops.push({type: 'lineTo', args: x2});\n              return;\n            }\n            var phi = phi * (Math.PI / 180.0);\n            rx = Math.abs(rx);\n            ry = Math.abs(ry);\n            var xPrime = rotClockwise(midPoint(x1, x2), phi);                // F.6.5.1\n            var xPrime2 = pointMul(xPrime, xPrime);\n            var rx2 = Math.pow(rx, 2);\n            var ry2 = Math.pow(ry, 2);\n    \n            var lambda = Math.sqrt(xPrime2[0]/rx2 + xPrime2[1]/ry2);\n            if (lambda > 1) {\n              rx *= lambda;\n              ry *= lambda;\n              rx2 = Math.pow(rx, 2);\n              ry2 = Math.pow(ry, 2);\n            }\n            var factor = Math.sqrt(Math.abs(rx2*ry2 - rx2*xPrime2[1] - ry2*xPrime2[0]) /\n              (rx2*xPrime2[1] + ry2*xPrime2[0]));\n            if (fA == fS) {\n              factor *= -1.0;\n            }\n            var cPrime = scale(factor, [rx*xPrime[1]/ry, -ry*xPrime[0]/rx]); // F.6.5.2\n            var c = sum(rotCounterClockwise(cPrime, phi), meanVec(x1, x2));  // F.6.5.3\n            var x1UnitVector = [(xPrime[0] - cPrime[0])/rx, (xPrime[1] - cPrime[1])/ry];\n            var x2UnitVector = [(-1.0*xPrime[0] - cPrime[0])/rx, (-1.0*xPrime[1] - cPrime[1])/ry];\n            var theta = angle([1, 0], x1UnitVector);                         // F.6.5.5\n            var deltaTheta = angle(x1UnitVector, x2UnitVector);              // F.6.5.6\n            var start = theta;\n            var end = theta+deltaTheta;\n            ops.push(\n              {type: 'save', args: []},\n              {type: 'translate', args: [c[0], c[1]]},\n              {type: 'rotate', args: [phi]},\n              {type: 'scale', args: [rx, ry]},\n              {type: 'arc', args: [0, 0, 1, start, end, 1-fS]},\n              {type: 'restore', args: []}\n              );\n          }\n    \n    \n        peg$result = peg$startRuleFunction();\n    \n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail({ type: \"end\", description: \"end of input\" });\n          }\n    \n          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n        }\n      }\n    \n      return {\n        SyntaxError: SyntaxError,\n        parse:       parse\n      };\n    })();\n\n    function Path_(arg) {\n      this.ops_ = [];\n      if (arg == undefined) {\n        return;\n      }\n      if (typeof arg == 'string') {\n        try {\n          this.ops_ = parser.parse(arg);\n        } catch(e) {\n          // Treat an invalid SVG path as an empty path.\n        }\n      } else if (arg.hasOwnProperty('ops_')) {\n        this.ops_ = arg.ops_.slice(0);\n      } else {\n        throw 'Error: ' + typeof arg + 'is not a valid argument to Path';\n      }\n    };\n\n    // TODO(jcgregorio) test for arcTo and implement via something.\n\n\n    // Path methods that map simply to the CanvasRenderingContext2D.\n    var simple_mapping = [\n      'closePath',\n      'moveTo',\n      'lineTo',\n      'quadraticCurveTo',\n      'bezierCurveTo',\n      'rect',\n      'arc',\n      'arcTo',\n      'ellipse',\n      'isPointInPath',\n      'isPointInStroke',\n      ];\n\n    function createFunction(name) {\n      return function() {\n        this.ops_.push({type: name, args: Array.prototype.slice.call(arguments, 0)});\n      };\n    }\n\n    // Add simple_mapping methods to Path2D.\n    for (var i=0; i<simple_mapping.length; i++) {\n      var name = simple_mapping[i];\n      Path_.prototype[name] = createFunction(name);\n    }\n\n    Path_.prototype['addPath'] = function(path, tr) {\n      var hasTx = false;\n      if (tr\n          && tr.a != undefined\n          && tr.b != undefined\n          && tr.c != undefined\n          && tr.d != undefined\n          && tr.e != undefined\n          && tr.f != undefined) {\n        hasTx = true;\n        this.ops_.push({type: 'save', args: []});\n        this.ops_.push({type: 'transform', args: [tr.a, tr.b, tr.c, tr.d, tr.e, tr.f]});\n      }\n      this.ops_ = this.ops_.concat(path.ops_);\n      if (hasTx) {\n        this.ops_.push({type: 'restore', args: []});\n      }\n    }\n\n    original_fill = CanvasRenderingContext2D.prototype.fill;\n    original_stroke = CanvasRenderingContext2D.prototype.stroke;\n    original_clip = CanvasRenderingContext2D.prototype.clip;\n    original_is_point_in_path = CanvasRenderingContext2D.prototype.isPointInPath;\n    original_is_point_in_stroke = CanvasRenderingContext2D.prototype.isPointInStroke;\n\n    // Replace methods on CanvasRenderingContext2D with ones that understand Path2D.\n    CanvasRenderingContext2D.prototype.fill = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        original_fill.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        original_fill.apply(this, arguments);\n      }\n    }\n\n    CanvasRenderingContext2D.prototype.stroke = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        original_stroke.call(this);\n      } else {\n        original_stroke.call(this);\n      }\n    }\n\n    CanvasRenderingContext2D.prototype.clip = function(arg) {\n      if (arg instanceof Path_) {\n        // Note that we don't save and restore the context state, since the\n        // clip region is part of the state. Not really a problem since the\n        // HTML 5 spec doesn't say that clip(path) doesn't affect the current\n        // path.\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        original_clip.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        original_clip.apply(this, arguments);\n      }\n    }\n\n    CanvasRenderingContext2D.prototype.isPointInPath = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        return original_is_point_in_path.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        return original_is_point_in_path.apply(this, arguments);\n      }\n    }\n    CanvasRenderingContext2D.prototype.isPointInStroke = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        return original_is_point_in_stroke.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        return original_is_point_in_stroke.apply(this, arguments);\n      }\n    }\n\n    // Set up externs.\n    Path2D = Path_;\n  })();\n}\n\n})(\n  typeof CanvasRenderingContext2D === \"undefined\" ? undefined : CanvasRenderingContext2D,\n  typeof require === \"undefined\" ? undefined : require\n);\n","import rough from \"../node_modules/roughjs/bin/rough\";\nimport \"../node_modules/canvas-5-polyfill/canvas\";\n\nvar RoughCanvas = L.Canvas.extend({\n  _initContainer: function () {\n    L.Canvas.prototype._initContainer.call(this);\n    this._rc = rough.canvas(this._container);\n  },\n\n  _updatePoly: function (layer, closed) {\n    if (!this._drawing) {\n      return;\n    }\n\n    var parts = layer._parts,\n      len = parts.length,\n      ctx = this._ctx;\n\n    if (!len) {\n      return;\n    }\n\n    var options = layer.options;\n    var pathOption = {};\n\n    pathOption.roughness = options.roughness || 1;\n    pathOption.bowing = options.bowing || 1;\n    pathOption.stroke = options.strokeColor || \"#000000\";\n    pathOption.strokeWidth = options.strokeWidth || 1;\n    if (closed) {\n      pathOption.fill = options.fillColor || options.color;\n      pathOption.fillStyle = options.fillStyle || \"\";\n      pathOption.fillWeight = options.fillWeight || \"\";\n      pathOption.hachureAngle = options.hachureAngle || -41;\n      pathOption.hachureGap = options.hachureGap || 4;\n      pathOption.simplification = options.simplification || 0.5;\n    }\n    pathOption.curveStepCount = options.curveStepCount || 9;\n\n    var svgPathStr = L.SVG.pointsToPath(parts, closed);\n    this._rc.path(svgPathStr, pathOption);\n\n    layer.options.fillOpacity = 0;\n    // layer.options.opacity = 0;\n    L.Canvas.prototype._updatePoly.call(this, layer, closed);\n  },\n\n  _onClick: function (e) {\n    var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;\n    console.log(point);\n\n\t\tfor (var order = this._drawFirst; order; order = order.next) {\n\t\t\tlayer = order.layer;\n\t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n\t\t\t\tif (!(e.type === 'click' || e.type !== 'preclick') || !this._map._draggableMoved(layer)) {\n\t\t\t\t\tclickedLayer = layer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (clickedLayer)  {\n\t\t\tDomEvent.fakeStop(e);\n\t\t\tthis._fireEvent([clickedLayer], e);\n\t\t}\n\t},\n});\n\nL.Canvas.RoughCanvas = RoughCanvas;\n\nL.Canvas.roughCanvas = () => {\n  return new RoughCanvas();\n};\n"],"names":["isType","token","type","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","ParsedPath","d","COMMAND","NUMBER","EOD","segments","parseData","processPoints","tokens","Array","match","substr","RegExp","$1","length","this","text","console","error","parseFloat","tokenize","index","mode","param_length","params","i","numbeToken","segment","key","data","push","first","currentPoint","point","_closed","toLowerCase","RoughPath","_position","_first","bezierReflectionPoint","quadReflectionPoint","parsed","x","y","closed","_linearPoints","lp","points","RoughArcConverter","from","to","radii","angle","largeArcFlag","sweepFlag","_segIndex","_numSegs","_rx","_ry","_sinPhi","_cosPhi","_C","_theta","_delta","_T","_from","radPerDeg","Math","PI","abs","sin","cos","x1dash","y1dash","root","numerator","sqrt","cxdash","cydash","calculateVectorAngle","dtheta","ceil","cosTheta1","sinTheta1","theta2","cosTheta2","sinTheta2","cp1","cp2","ux","uy","vx","vy","ta","atan2","tb","PathFitter","sets","simplification","outSets","set","estLength","floor","reduce","p1","p2","pow","count","slice","minArea","minIndex","distance","b","area","splice","Segment","xi","Number","MAX_VALUE","yi","px1","py1","px2","py2","_undefined","otherSegment","isUndefined","grad1","grad2","int1","int2","min","max","HachureIterator","top","bottom","left","right","gap","sinAngle","cosAngle","tanAngle","deltaX","hGap","pos","sLeft","sRight","line","xLower","xUpper","yLower","yUpper","intersects","lineLength","getIntersectingLines","intersections","s1","s2","affine","cx","cy","sinAnglePrime","cosAnglePrime","R","hachureLinesForPolygon","o","ret","hachureAngle","hachureGap","strokeWidth","rect","tan","it","nextLine","lines","hachureLinesForEllipse","width","height","renderer","rx","ry","getOffset","fweight","fillWeight","aspectRatio","hyp","gapPrime","halfLen","xPos","HachureFiller","_fillPolygon","_fillEllipse","connectEnds","ops","renderLines","prevPoint","concat","doubleLine","ZigZagFiller","HatchFiller","o2","Object","assign","set2","DotFiller","curveStepCount","dotsOnLines","dl","alpha","atan","dy","dx","ellipse","fillers","getFiller","fillerName","fillStyle","RoughRenderer","x1","y1","x2","y2","close","len","linearPath","polygon","o1","_curveWithOffset","roughness","increment","_ellipse","start","stop","roughClosure","strt","stp","ellipseInc","arcInc","_arc","op","path","replace","p","linearPoints","fit","prev","opList","_processSegment","offset","maxRandomnessOffset","fillPolygon","fillEllipse","patternFillPolygon","random","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","closePoint","curveTightness","cachedVertArray","ro","overlap","radOffset","_curve","ps","ros","f","setPosition","seg","prevSeg","delta","ob","_bezierTo","prevKey","ref","offset1","offset2","arcConverter","getNextSegment","hasSelf","self","roughScript","document","currentScript","src","RoughGeneratorBase","config","surface","defaultOptions","stroke","workly","async","noWorker","worklySource","worklyURL","code","ourl","URL","createObjectURL","Blob","proxy","createRenderer","options","_options","shape","val","w","baseVal","value","size","ns","svg","createElementNS","setAttribute","pathNode","appendChild","body","bb","getBBox","removeChild","err","canvasSize","getCanvasSize","drawable","paths","drawing","opsToPath","fill","fillSketch","pattern","viewBox","round","patternUnits","item","trim","RoughGenerator","_drawable","lib","solidFillPolygon","rectangle","patternFillEllipse","diameter","arc","patternFillArc","curve","computePolygonSize","fillPoints","polygonPath","computePathSize","svgPath","hasDocument","RoughCanvasBase","canvas","ctx","getContext","getDefaultOptions","save","strokeStyle","lineWidth","_drawToContext","restore","p2d","Path2D","doc","ownerDocument","hcanvas","createElement","hcontext","bbox","computeBBox","translate","createPattern","beginPath","moveTo","bezierCurveTo","quadraticCurveTo","lineTo","RoughCanvas","gen","_this","draw","circle","RoughGeneratorAsync","RoughCanvasAsync","genAsync","_this2","CanvasRenderingContext2D","nodeRequire","undefined","Context2d","prototype","radiusX","radiusY","rotation","startAngle","endAngle","antiClockwise","rotate","scale","addPath","Path_","arg","ops_","parser","parse","e","hasOwnProperty","SyntaxError","message","expected","found","column","name","child","parent","ctor","constructor","peg$subclass","Error","input","peg$result","arguments","peg$FAILED","peg$startRuleFunctions","svg_path","peg$parsesvg_path","peg$startRuleFunction","peg$c0","peg$c2","peg$c3","peg$c4","peg$c5","description","peg$c6","ch","args","moveCh","firstSubPath","makeAbsolute","peg$c7","one","rest","concatSequence","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","makeAbsoluteFromX","peg$c17","peg$c18","peg$c19","makeAbsoluteFromY","peg$c20","peg$c21","peg$c22","makeAbsoluteMultiple","peg$c23","last","peg$c24","peg$c25","peg$c26","makeReflected","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","reflected","lastControl","peg$c34","peg$c35","peg$c36","lastCoord","absArgs","ellipseFromEllipticalArc","apply","peg$c37","xrot","large","sweep","flatten","join","parseInt","peg$c38","peg$c39","number","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","digits","peg$c57","peg$c58","peg$currPos","peg$cachedPos","peg$cachedPosDetails","seenCR","peg$maxFailPos","peg$maxFailExpected","startRule","peg$computePosDetails","details","startPos","endPos","charAt","advance","peg$fail","peg$buildException","posDetails","sort","cleanupExpected","expectedDescs","hex","charCodeAt","toString","toUpperCase","stringEscape","buildMessage","s0","s3","s4","peg$parsewsp","peg$parsemoveTo_drawTo_commandGroups","peg$parsemoveTo_drawTo_commandGroup","peg$parsemoveto","peg$parsedrawto_commands","peg$parsedrawto_command","peg$parseclosepath","peg$parselineto","peg$parsehorizontal_lineto","peg$parsevertical_lineto","peg$parsecurveto","peg$parsesmooth_curveto","peg$parsequadratic_bezier_curveto","peg$parsesmooth_quadratic_bezier_curveto","peg$parseelliptical_arc","test","peg$parsemoveto_argument_sequence","peg$parsecoordinate_pair","peg$parsecomma_wsp","peg$parselineto_argument_sequence","peg$parsecoordinate_sequence","peg$parsecoordinate","peg$parsecurveto_argument_sequence","peg$parsecurveto_argument","s5","peg$parsesmooth_curveto_argument_sequence","peg$parsesmooth_curveto_argument","peg$parsequadratic_bezier_curveto_argument_sequence","peg$parsequadratic_bezier_curveto_argument","peg$parsesmooth_quadratic_bezier_curveto_argument_sequence","peg$parseelliptical_arc_argument_sequence","peg$parseelliptical_arc_argument","s7","s8","s9","s10","s11","peg$parsenonnegative_number","peg$parsenumber","peg$parseflag","peg$parsefloating_point_constant","peg$parsedigit_sequence","peg$parsesign","peg$parsecomma","peg$parsefractional_constant","peg$parseexponent","lastCh","flat","coord","indexOf","seq","r","lastPosCopy","rem","mag","dot","u","ratio","clamp","sign","acos","rotClockwise","cost","sint","rotCounterClockwise","midPoint","meanVec","pointMul","sum","phi","fA","fS","xPrime","xPrime2","rx2","ry2","lambda","factor","cPrime","x1UnitVector","x2UnitVector","theta","end","simple_mapping","createFunction","call","tr","hasTx","original_fill","original_stroke","original_clip","clip","original_is_point_in_path","isPointInPath","original_is_point_in_stroke","isPointInStroke","require","Canvas","extend","_initContainer","_rc","rough","_container","_updatePoly","layer","_drawing","parts","_parts","_ctx","pathOption","strokeColor","fillColor","color","svgPathStr","SVG","pointsToPath","fillOpacity","_onClick","clickedLayer","_map","mouseEventToLayerPoint","log","order","_drawFirst","next","interactive","_containsPoint","_draggableMoved","DomEvent","fakeStop","_fireEvent","roughCanvas"],"mappings":"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"}