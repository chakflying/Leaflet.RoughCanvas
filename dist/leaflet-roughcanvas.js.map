{"version":3,"file":"leaflet-roughcanvas.js","sources":["../node_modules/roughjs/bin/path.js","../node_modules/roughjs/bin/geometry.js","../node_modules/roughjs/bin/utils/hachure.js","../node_modules/roughjs/bin/fillers/filler-utils.js","../node_modules/roughjs/bin/fillers/hachure-filler.js","../node_modules/roughjs/bin/fillers/zigzag-filler.js","../node_modules/roughjs/bin/fillers/hatch-filler.js","../node_modules/roughjs/bin/fillers/dot-filler.js","../node_modules/roughjs/bin/fillers/filler.js","../node_modules/roughjs/bin/renderer.js","../node_modules/roughjs/bin/renderer-factory.js","../node_modules/roughjs/bin/generator-base.js","../node_modules/roughjs/bin/generator.js","../node_modules/roughjs/bin/canvas-base.js","../node_modules/roughjs/bin/canvas.js","../node_modules/roughjs/bin/generator-async.js","../node_modules/roughjs/bin/canvas-async.js","../node_modules/roughjs/bin/svg-base.js","../node_modules/roughjs/bin/svg.js","../node_modules/roughjs/bin/svg-async.js","../node_modules/roughjs/bin/rough.js","../node_modules/canvas-5-polyfill/canvas.js","../src/main.js"],"sourcesContent":["function isType(token, type) {\n    return token.type === type;\n}\nconst PARAMS = {\n    A: 7,\n    a: 7,\n    C: 6,\n    c: 6,\n    H: 1,\n    h: 1,\n    L: 2,\n    l: 2,\n    M: 2,\n    m: 2,\n    Q: 4,\n    q: 4,\n    S: 4,\n    s: 4,\n    T: 4,\n    t: 2,\n    V: 1,\n    v: 1,\n    Z: 0,\n    z: 0\n};\nclass ParsedPath {\n    constructor(d) {\n        this.COMMAND = 0;\n        this.NUMBER = 1;\n        this.EOD = 2;\n        this.segments = [];\n        this.parseData(d);\n        this.processPoints();\n    }\n    tokenize(d) {\n        const tokens = new Array();\n        while (d !== '') {\n            if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n                tokens[tokens.length] = { type: this.COMMAND, text: RegExp.$1 };\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n                tokens[tokens.length] = { type: this.NUMBER, text: `${parseFloat(RegExp.$1)}` };\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                console.error('Unrecognized segment command: ' + d);\n                return [];\n            }\n        }\n        tokens[tokens.length] = { type: this.EOD, text: '' };\n        return tokens;\n    }\n    parseData(d) {\n        const tokens = this.tokenize(d);\n        let index = 0;\n        let token = tokens[index];\n        let mode = 'BOD';\n        this.segments = new Array();\n        while (!isType(token, this.EOD)) {\n            let param_length;\n            const params = new Array();\n            if (mode === 'BOD') {\n                if (token.text === 'M' || token.text === 'm') {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n                else {\n                    this.parseData('M0,0' + d);\n                    return;\n                }\n            }\n            else {\n                if (isType(token, this.NUMBER)) {\n                    param_length = PARAMS[mode];\n                }\n                else {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n            }\n            if ((index + param_length) < tokens.length) {\n                for (let i = index; i < index + param_length; i++) {\n                    const numbeToken = tokens[i];\n                    if (isType(numbeToken, this.NUMBER)) {\n                        params[params.length] = +numbeToken.text;\n                    }\n                    else {\n                        console.error('Parameter type is not a number: ' + mode + ',' + numbeToken.text);\n                        return;\n                    }\n                }\n                if (typeof PARAMS[mode] === 'number') {\n                    const segment = { key: mode, data: params };\n                    this.segments.push(segment);\n                    index += param_length;\n                    token = tokens[index];\n                    if (mode === 'M')\n                        mode = 'L';\n                    if (mode === 'm')\n                        mode = 'l';\n                }\n                else {\n                    console.error('Unsupported segment type: ' + mode);\n                    return;\n                }\n            }\n            else {\n                console.error('Path data ended before all parameters were found');\n            }\n        }\n    }\n    get closed() {\n        if (typeof this._closed === 'undefined') {\n            this._closed = false;\n            for (const s of this.segments) {\n                if (s.key.toLowerCase() === 'z') {\n                    this._closed = true;\n                }\n            }\n        }\n        return this._closed;\n    }\n    processPoints() {\n        let first = null;\n        let currentPoint = [0, 0];\n        for (let i = 0; i < this.segments.length; i++) {\n            const s = this.segments[i];\n            switch (s.key) {\n                case 'M':\n                case 'L':\n                case 'T':\n                    s.point = [s.data[0], s.data[1]];\n                    break;\n                case 'm':\n                case 'l':\n                case 't':\n                    s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n                    break;\n                case 'H':\n                    s.point = [s.data[0], currentPoint[1]];\n                    break;\n                case 'h':\n                    s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n                    break;\n                case 'V':\n                    s.point = [currentPoint[0], s.data[0]];\n                    break;\n                case 'v':\n                    s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n                    break;\n                case 'z':\n                case 'Z':\n                    if (first) {\n                        s.point = [first[0], first[1]];\n                    }\n                    break;\n                case 'C':\n                    s.point = [s.data[4], s.data[5]];\n                    break;\n                case 'c':\n                    s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n                    break;\n                case 'S':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 's':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'Q':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 'q':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'A':\n                    s.point = [s.data[5], s.data[6]];\n                    break;\n                case 'a':\n                    s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n                    break;\n            }\n            if (s.key === 'm' || s.key === 'M') {\n                first = null;\n            }\n            if (s.point) {\n                currentPoint = s.point;\n                if (!first) {\n                    first = s.point;\n                }\n            }\n            if (s.key === 'z' || s.key === 'Z') {\n                first = null;\n            }\n        }\n    }\n}\nexport class RoughPath {\n    constructor(d) {\n        this._position = [0, 0];\n        this._first = null;\n        this.bezierReflectionPoint = null;\n        this.quadReflectionPoint = null;\n        this.parsed = new ParsedPath(d);\n    }\n    get segments() {\n        return this.parsed.segments;\n    }\n    get closed() {\n        return this.parsed.closed;\n    }\n    get linearPoints() {\n        if (!this._linearPoints) {\n            const lp = [];\n            let points = [];\n            for (const s of this.parsed.segments) {\n                const key = s.key.toLowerCase();\n                if (key === 'm' || key === 'z') {\n                    if (points.length) {\n                        lp.push(points);\n                        points = [];\n                    }\n                    if (key === 'z') {\n                        continue;\n                    }\n                }\n                if (s.point) {\n                    points.push(s.point);\n                }\n            }\n            if (points.length) {\n                lp.push(points);\n                points = [];\n            }\n            this._linearPoints = lp;\n        }\n        return this._linearPoints;\n    }\n    get first() {\n        return this._first;\n    }\n    set first(v) {\n        this._first = v;\n    }\n    setPosition(x, y) {\n        this._position = [x, y];\n        if (!this._first) {\n            this._first = [x, y];\n        }\n    }\n    get position() {\n        return this._position;\n    }\n    get x() {\n        return this._position[0];\n    }\n    get y() {\n        return this._position[1];\n    }\n}\n// Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\nexport class RoughArcConverter {\n    constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n        this._segIndex = 0;\n        this._numSegs = 0;\n        this._rx = 0;\n        this._ry = 0;\n        this._sinPhi = 0;\n        this._cosPhi = 0;\n        this._C = [0, 0];\n        this._theta = 0;\n        this._delta = 0;\n        this._T = 0;\n        this._from = from;\n        if (from[0] === to[0] && from[1] === to[1]) {\n            return;\n        }\n        const radPerDeg = Math.PI / 180;\n        this._rx = Math.abs(radii[0]);\n        this._ry = Math.abs(radii[1]);\n        this._sinPhi = Math.sin(angle * radPerDeg);\n        this._cosPhi = Math.cos(angle * radPerDeg);\n        const x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n        const y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n        let root = 0;\n        const numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n        if (numerator < 0) {\n            const s = Math.sqrt(1 - (numerator / (this._rx * this._rx * this._ry * this._ry)));\n            this._rx = this._rx * s;\n            this._ry = this._ry * s;\n            root = 0;\n        }\n        else {\n            root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) *\n                Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n        }\n        const cxdash = root * this._rx * y1dash / this._ry;\n        const cydash = -root * this._ry * x1dash / this._rx;\n        this._C = [0, 0];\n        this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n        this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n        this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n        let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n        if ((!sweepFlag) && (dtheta > 0)) {\n            dtheta -= 2 * Math.PI;\n        }\n        else if (sweepFlag && (dtheta < 0)) {\n            dtheta += 2 * Math.PI;\n        }\n        this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n        this._delta = dtheta / this._numSegs;\n        this._T = (8 / 3) * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n    }\n    getNextSegment() {\n        if (this._segIndex === this._numSegs) {\n            return null;\n        }\n        const cosTheta1 = Math.cos(this._theta);\n        const sinTheta1 = Math.sin(this._theta);\n        const theta2 = this._theta + this._delta;\n        const cosTheta2 = Math.cos(theta2);\n        const sinTheta2 = Math.sin(theta2);\n        const to = [\n            this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0],\n            this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]\n        ];\n        const cp1 = [\n            this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1),\n            this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)\n        ];\n        const cp2 = [\n            to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2),\n            to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)\n        ];\n        this._theta = theta2;\n        this._from = [to[0], to[1]];\n        this._segIndex++;\n        return {\n            cp1: cp1,\n            cp2: cp2,\n            to: to\n        };\n    }\n    calculateVectorAngle(ux, uy, vx, vy) {\n        const ta = Math.atan2(uy, ux);\n        const tb = Math.atan2(vy, vx);\n        if (tb >= ta)\n            return tb - ta;\n        return 2 * Math.PI - (ta - tb);\n    }\n}\nexport class PathFitter {\n    constructor(sets, closed) {\n        this.sets = sets;\n        this.closed = closed;\n    }\n    fit(simplification) {\n        const outSets = [];\n        for (const set of this.sets) {\n            const length = set.length;\n            let estLength = Math.floor(simplification * length);\n            if (estLength < 5) {\n                if (length <= 5) {\n                    continue;\n                }\n                estLength = 5;\n            }\n            outSets.push(this.reduce(set, estLength));\n        }\n        let d = '';\n        for (const set of outSets) {\n            for (let i = 0; i < set.length; i++) {\n                const point = set[i];\n                if (i === 0) {\n                    d += 'M' + point[0] + ',' + point[1];\n                }\n                else {\n                    d += 'L' + point[0] + ',' + point[1];\n                }\n            }\n            if (this.closed) {\n                d += 'z ';\n            }\n        }\n        return d;\n    }\n    distance(p1, p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n    reduce(set, count) {\n        if (set.length <= count) {\n            return set;\n        }\n        const points = set.slice(0);\n        while (points.length > count) {\n            const areas = [];\n            let minArea = -1;\n            let minIndex = -1;\n            for (let i = 1; i < (points.length - 1); i++) {\n                const a = this.distance(points[i - 1], points[i]);\n                const b = this.distance(points[i], points[i + 1]);\n                const c = this.distance(points[i - 1], points[i + 1]);\n                const s = (a + b + c) / 2.0;\n                const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n                areas.push(area);\n                if ((minArea < 0) || (area < minArea)) {\n                    minArea = area;\n                    minIndex = i;\n                }\n            }\n            if (minIndex > 0) {\n                points.splice(minIndex, 1);\n            }\n            else {\n                break;\n            }\n        }\n        return points;\n    }\n}\n","export class Segment {\n    constructor(p1, p2) {\n        this.xi = Number.MAX_VALUE;\n        this.yi = Number.MAX_VALUE;\n        this.px1 = p1[0];\n        this.py1 = p1[1];\n        this.px2 = p2[0];\n        this.py2 = p2[1];\n        this.a = this.py2 - this.py1;\n        this.b = this.px1 - this.px2;\n        this.c = this.px2 * this.py1 - this.px1 * this.py2;\n        this._undefined = ((this.a === 0) && (this.b === 0) && (this.c === 0));\n    }\n    isUndefined() {\n        return this._undefined;\n    }\n    intersects(otherSegment) {\n        if (this.isUndefined() || otherSegment.isUndefined()) {\n            return false;\n        }\n        let grad1 = Number.MAX_VALUE;\n        let grad2 = Number.MAX_VALUE;\n        let int1 = 0, int2 = 0;\n        const a = this.a, b = this.b, c = this.c;\n        if (Math.abs(b) > 0.00001) {\n            grad1 = -a / b;\n            int1 = -c / b;\n        }\n        if (Math.abs(otherSegment.b) > 0.00001) {\n            grad2 = -otherSegment.a / otherSegment.b;\n            int2 = -otherSegment.c / otherSegment.b;\n        }\n        if (grad1 === Number.MAX_VALUE) {\n            if (grad2 === Number.MAX_VALUE) {\n                if ((-c / a) !== (-otherSegment.c / otherSegment.a)) {\n                    return false;\n                }\n                if ((this.py1 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px1;\n                    this.yi = this.py1;\n                    return true;\n                }\n                if ((this.py2 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py2 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px2;\n                    this.yi = this.py2;\n                    return true;\n                }\n                return false;\n            }\n            this.xi = this.px1;\n            this.yi = (grad2 * this.xi + int2);\n            if (((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) || ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(otherSegment.a) < 0.00001) {\n                if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad2 === Number.MAX_VALUE) {\n            this.xi = otherSegment.px1;\n            this.yi = grad1 * this.xi + int1;\n            if (((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) || ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(a) < 0.00001) {\n                if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad1 === grad2) {\n            if (int1 !== int2) {\n                return false;\n            }\n            if ((this.px1 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                this.xi = this.px1;\n                this.yi = this.py1;\n                return true;\n            }\n            if ((this.px2 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px2 <= Math.max(otherSegment.px1, otherSegment.px2))) {\n                this.xi = this.px2;\n                this.yi = this.py2;\n                return true;\n            }\n            return false;\n        }\n        this.xi = ((int2 - int1) / (grad1 - grad2));\n        this.yi = (grad1 * this.xi + int1);\n        if (((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) || ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001)) {\n            return false;\n        }\n        return true;\n    }\n}\n","import { Segment } from '../geometry';\nexport class HachureIterator {\n    constructor(top, bottom, left, right, gap, sinAngle, cosAngle, tanAngle) {\n        this.deltaX = 0;\n        this.hGap = 0;\n        this.top = top;\n        this.bottom = bottom;\n        this.left = left;\n        this.right = right;\n        this.gap = gap;\n        this.sinAngle = sinAngle;\n        this.tanAngle = tanAngle;\n        if (Math.abs(sinAngle) < 0.0001) {\n            this.pos = left + gap;\n        }\n        else if (Math.abs(sinAngle) > 0.9999) {\n            this.pos = top + gap;\n        }\n        else {\n            this.deltaX = (bottom - top) * Math.abs(tanAngle);\n            this.pos = left - Math.abs(this.deltaX);\n            this.hGap = Math.abs(gap / cosAngle);\n            this.sLeft = new Segment([left, bottom], [left, top]);\n            this.sRight = new Segment([right, bottom], [right, top]);\n        }\n    }\n    nextLine() {\n        if (Math.abs(this.sinAngle) < 0.0001) {\n            if (this.pos < this.right) {\n                const line = [this.pos, this.top, this.pos, this.bottom];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else if (Math.abs(this.sinAngle) > 0.9999) {\n            if (this.pos < this.bottom) {\n                const line = [this.left, this.pos, this.right, this.pos];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else {\n            let xLower = this.pos - this.deltaX / 2;\n            let xUpper = this.pos + this.deltaX / 2;\n            let yLower = this.bottom;\n            let yUpper = this.top;\n            if (this.pos < (this.right + this.deltaX)) {\n                while (((xLower < this.left) && (xUpper < this.left)) || ((xLower > this.right) && (xUpper > this.right))) {\n                    this.pos += this.hGap;\n                    xLower = this.pos - this.deltaX / 2;\n                    xUpper = this.pos + this.deltaX / 2;\n                    if (this.pos > (this.right + this.deltaX)) {\n                        return null;\n                    }\n                }\n                const s = new Segment([xLower, yLower], [xUpper, yUpper]);\n                if (this.sLeft && s.intersects(this.sLeft)) {\n                    xLower = s.xi;\n                    yLower = s.yi;\n                }\n                if (this.sRight && s.intersects(this.sRight)) {\n                    xUpper = s.xi;\n                    yUpper = s.yi;\n                }\n                if (this.tanAngle > 0) {\n                    xLower = this.right - (xLower - this.left);\n                    xUpper = this.right - (xUpper - this.left);\n                }\n                const line = [xLower, yLower, xUpper, yUpper];\n                this.pos += this.hGap;\n                return line;\n            }\n        }\n        return null;\n    }\n}\n","import { Segment } from '../geometry';\nimport { HachureIterator } from '../utils/hachure';\nexport function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getIntersectingLines(line, points) {\n    const intersections = [];\n    const s1 = new Segment([line[0], line[1]], [line[2], line[3]]);\n    for (let i = 0; i < points.length; i++) {\n        const s2 = new Segment(points[i], points[(i + 1) % points.length]);\n        if (s1.intersects(s2)) {\n            intersections.push([s1.xi, s1.yi]);\n        }\n    }\n    return intersections;\n}\nexport function affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {\n    const A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;\n    const B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;\n    const C = cosAnglePrime;\n    const D = sinAnglePrime;\n    const E = -R * sinAnglePrime;\n    const F = R * cosAnglePrime;\n    return [\n        A + C * x + D * y,\n        B + E * x + F * y\n    ];\n}\nexport function hachureLinesForPolygon(points, o) {\n    const ret = [];\n    if (points && points.length) {\n        let left = points[0][0];\n        let right = points[0][0];\n        let top = points[0][1];\n        let bottom = points[0][1];\n        for (let i = 1; i < points.length; i++) {\n            left = Math.min(left, points[i][0]);\n            right = Math.max(right, points[i][0]);\n            top = Math.min(top, points[i][1]);\n            bottom = Math.max(bottom, points[i][1]);\n        }\n        const angle = o.hachureAngle;\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const radPerDeg = Math.PI / 180;\n        const hachureAngle = (angle % 180) * radPerDeg;\n        const cosAngle = Math.cos(hachureAngle);\n        const sinAngle = Math.sin(hachureAngle);\n        const tanAngle = Math.tan(hachureAngle);\n        const it = new HachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);\n        let rect;\n        while ((rect = it.nextLine()) != null) {\n            const lines = getIntersectingLines(rect, points);\n            for (let i = 0; i < lines.length; i++) {\n                if (i < (lines.length - 1)) {\n                    const p1 = lines[i];\n                    const p2 = lines[i + 1];\n                    ret.push([p1, p2]);\n                }\n            }\n        }\n    }\n    return ret;\n}\nexport function hachureLinesForEllipse(cx, cy, width, height, o, renderer) {\n    const ret = [];\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += renderer.getOffset(-rx * 0.05, rx * 0.05, o);\n    ry += renderer.getOffset(-ry * 0.05, ry * 0.05, o);\n    const angle = o.hachureAngle;\n    let gap = o.hachureGap;\n    if (gap <= 0) {\n        gap = o.strokeWidth * 4;\n    }\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n    }\n    const radPerDeg = Math.PI / 180;\n    const hachureAngle = (angle % 180) * radPerDeg;\n    const tanAngle = Math.tan(hachureAngle);\n    const aspectRatio = ry / rx;\n    const hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);\n    const sinAnglePrime = aspectRatio * tanAngle / hyp;\n    const cosAnglePrime = 1 / hyp;\n    const gapPrime = gap / ((rx * ry / Math.sqrt((ry * cosAnglePrime) * (ry * cosAnglePrime) + (rx * sinAnglePrime) * (rx * sinAnglePrime))) / rx);\n    let halfLen = Math.sqrt((rx * rx) - (cx - rx + gapPrime) * (cx - rx + gapPrime));\n    for (let xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {\n        halfLen = Math.sqrt((rx * rx) - (cx - xPos) * (cx - xPos));\n        const p1 = affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        const p2 = affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        ret.push([p1, p2]);\n    }\n    return ret;\n}\n","import { hachureLinesForPolygon, hachureLinesForEllipse } from './filler-utils';\nexport class HachureFiller {\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        return this._fillEllipse(cx, cy, width, height, o);\n    }\n    _fillPolygon(points, o, connectEnds = false) {\n        const lines = hachureLinesForPolygon(points, o);\n        const ops = this.renderLines(lines, o, connectEnds);\n        return { type: 'fillSketch', ops };\n    }\n    _fillEllipse(cx, cy, width, height, o, connectEnds = false) {\n        const lines = hachureLinesForEllipse(cx, cy, width, height, o, this.renderer);\n        const ops = this.renderLines(lines, o, connectEnds);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o, connectEnds) {\n        let ops = [];\n        let prevPoint = null;\n        for (const line of lines) {\n            ops = ops.concat(this.renderer.doubleLine(line[0][0], line[0][1], line[1][0], line[1][1], o));\n            if (connectEnds && prevPoint) {\n                ops = ops.concat(this.renderer.doubleLine(prevPoint[0], prevPoint[1], line[0][0], line[0][1], o));\n            }\n            prevPoint = line[1];\n        }\n        return ops;\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o, true);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        return this._fillEllipse(cx, cy, width, height, o, true);\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        const set = this._fillPolygon(points, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygon(points, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        const set = this._fillEllipse(cx, cy, width, height, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillEllipse(cx, cy, width, height, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n","import { hachureLinesForPolygon, hachureLinesForEllipse, lineLength } from './filler-utils';\nexport class DotFiller {\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n    fillPolygon(points, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0 });\n        const lines = hachureLinesForPolygon(points, o);\n        return this.dotsOnLines(lines, o);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0 });\n        const lines = hachureLinesForEllipse(cx, cy, width, height, o, this.renderer);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        let ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const alpha = Math.atan((line[1][1] - line[0][1]) / (line[1][0] - line[0][0]));\n            for (let i = 0; i < count; i++) {\n                const l = gap * (i + 1);\n                const dy = l * Math.sin(alpha);\n                const dx = l * Math.cos(alpha);\n                const c = [line[0][0] - dx, line[0][1] + dy];\n                const cx = this.renderer.getOffset(c[0] - gap / 4, c[0] + gap / 4, o);\n                const cy = this.renderer.getOffset(c[1] - gap / 4, c[1] + gap / 4, o);\n                const ellipse = this.renderer.ellipse(cx, cy, fweight, fweight, o);\n                ops = ops.concat(ellipse.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nconst fillers = {};\nexport function getFiller(renderer, o) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(renderer);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(renderer);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(renderer);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(renderer);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n","import { RoughPath, RoughArcConverter, PathFitter } from './path.js';\nimport { getFiller } from './fillers/filler';\nexport class RoughRenderer {\n    line(x1, y1, x2, y2, o) {\n        const ops = this.doubleLine(x1, y1, x2, y2, o);\n        return { type: 'path', ops };\n    }\n    linearPath(points, close, o) {\n        const len = (points || []).length;\n        if (len > 2) {\n            let ops = [];\n            for (let i = 0; i < (len - 1); i++) {\n                ops = ops.concat(this.doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n            }\n            if (close) {\n                ops = ops.concat(this.doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n            }\n            return { type: 'path', ops };\n        }\n        else if (len === 2) {\n            return this.line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n        }\n        return { type: 'path', ops: [] };\n    }\n    polygon(points, o) {\n        return this.linearPath(points, true, o);\n    }\n    rectangle(x, y, width, height, o) {\n        const points = [\n            [x, y], [x + width, y], [x + width, y + height], [x, y + height]\n        ];\n        return this.polygon(points, o);\n    }\n    curve(points, o) {\n        const o1 = this._curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n        const o2 = this._curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    ellipse(x, y, width, height, o) {\n        const increment = (Math.PI * 2) / o.curveStepCount;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.05, rx * 0.05, o);\n        ry += this.getOffset(-ry * 0.05, ry * 0.05, o);\n        const o1 = this._ellipse(increment, x, y, rx, ry, 1, increment * this.getOffset(0.1, this.getOffset(0.4, 1, o), o), o);\n        const o2 = this._ellipse(increment, x, y, rx, ry, 1.5, 0, o);\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n        const cx = x;\n        const cy = y;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.01, rx * 0.01, o);\n        ry += this.getOffset(-ry * 0.01, ry * 0.01, o);\n        let strt = start;\n        let stp = stop;\n        while (strt < 0) {\n            strt += Math.PI * 2;\n            stp += Math.PI * 2;\n        }\n        if ((stp - strt) > (Math.PI * 2)) {\n            strt = 0;\n            stp = Math.PI * 2;\n        }\n        const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n        const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n        const o1 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n        const o2 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        let ops = o1.concat(o2);\n        if (closed) {\n            if (roughClosure) {\n                ops = ops.concat(this.doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));\n                ops = ops.concat(this.doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n            }\n            else {\n                ops.push({ op: 'lineTo', data: [cx, cy] });\n                ops.push({ op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n            }\n        }\n        return { type: 'path', ops };\n    }\n    svgPath(path, o) {\n        path = (path || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        let p = new RoughPath(path);\n        if (o.simplification) {\n            const fitter = new PathFitter(p.linearPoints, p.closed);\n            const d = fitter.fit(o.simplification);\n            p = new RoughPath(d);\n        }\n        let ops = [];\n        const segments = p.segments || [];\n        for (let i = 0; i < segments.length; i++) {\n            const s = segments[i];\n            const prev = i > 0 ? segments[i - 1] : null;\n            const opList = this._processSegment(p, s, prev, o);\n            if (opList && opList.length) {\n                ops = ops.concat(opList);\n            }\n        }\n        return { type: 'path', ops };\n    }\n    solidFillPolygon(points, o) {\n        const ops = [];\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + this.getOffset(-offset, offset, o), points[0][1] + this.getOffset(-offset, offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + this.getOffset(-offset, offset, o), points[i][1] + this.getOffset(-offset, offset, o)] });\n                }\n            }\n        }\n        return { type: 'fillPath', ops };\n    }\n    patternFillPolygon(points, o) {\n        const filler = getFiller(this, o);\n        return filler.fillPolygon(points, o);\n    }\n    patternFillEllipse(cx, cy, width, height, o) {\n        const filler = getFiller(this, o);\n        return filler.fillEllipse(cx, cy, width, height, o);\n    }\n    patternFillArc(x, y, width, height, start, stop, o) {\n        const cx = x;\n        const cy = y;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.01, rx * 0.01, o);\n        ry += this.getOffset(-ry * 0.01, ry * 0.01, o);\n        let strt = start;\n        let stp = stop;\n        while (strt < 0) {\n            strt += Math.PI * 2;\n            stp += Math.PI * 2;\n        }\n        if ((stp - strt) > (Math.PI * 2)) {\n            strt = 0;\n            stp = Math.PI * 2;\n        }\n        const increment = (stp - strt) / o.curveStepCount;\n        const points = [];\n        for (let angle = strt; angle <= stp; angle = angle + increment) {\n            points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n        }\n        points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n        points.push([cx, cy]);\n        return this.patternFillPolygon(points, o);\n    }\n    /// \n    getOffset(min, max, ops) {\n        return ops.roughness * ((Math.random() * (max - min)) + min);\n    }\n    doubleLine(x1, y1, x2, y2, o) {\n        const o1 = this._line(x1, y1, x2, y2, o, true, false);\n        const o2 = this._line(x1, y1, x2, y2, o, true, true);\n        return o1.concat(o2);\n    }\n    _line(x1, y1, x2, y2, o, move, overlay) {\n        const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n        let offset = o.maxRandomnessOffset || 0;\n        if ((offset * offset * 100) > lengthSq) {\n            offset = Math.sqrt(lengthSq) / 10;\n        }\n        const halfOffset = offset / 2;\n        const divergePoint = 0.2 + Math.random() * 0.2;\n        let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n        let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n        midDispX = this.getOffset(-midDispX, midDispX, o);\n        midDispY = this.getOffset(-midDispY, midDispY, o);\n        const ops = [];\n        if (move) {\n            if (overlay) {\n                ops.push({\n                    op: 'move', data: [\n                        x1 + this.getOffset(-halfOffset, halfOffset, o),\n                        y1 + this.getOffset(-halfOffset, halfOffset, o)\n                    ]\n                });\n            }\n            else {\n                ops.push({\n                    op: 'move', data: [\n                        x1 + this.getOffset(-offset, offset, o),\n                        y1 + this.getOffset(-offset, offset, o)\n                    ]\n                });\n            }\n        }\n        if (overlay) {\n            ops.push({\n                op: 'bcurveTo', data: [\n                    midDispX + x1 + (x2 - x1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispY + y1 + (y2 - y1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispX + x1 + 2 * (x2 - x1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispY + y1 + 2 * (y2 - y1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    x2 + this.getOffset(-halfOffset, halfOffset, o),\n                    y2 + this.getOffset(-halfOffset, halfOffset, o)\n                ]\n            });\n        }\n        else {\n            ops.push({\n                op: 'bcurveTo', data: [\n                    midDispX + x1 + (x2 - x1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispY + y1 + (y2 - y1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispX + x1 + 2 * (x2 - x1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispY + y1 + 2 * (y2 - y1) * divergePoint + this.getOffset(-offset, offset, o),\n                    x2 + this.getOffset(-offset, offset, o),\n                    y2 + this.getOffset(-offset, offset, o)\n                ]\n            });\n        }\n        return ops;\n    }\n    _curve(points, closePoint, o) {\n        const len = points.length;\n        let ops = [];\n        if (len > 3) {\n            const b = [];\n            const s = 1 - o.curveTightness;\n            ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n            for (let i = 1; (i + 2) < len; i++) {\n                const cachedVertArray = points[i];\n                b[0] = [cachedVertArray[0], cachedVertArray[1]];\n                b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n                b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n                b[3] = [points[i + 1][0], points[i + 1][1]];\n                ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n            }\n            if (closePoint && closePoint.length === 2) {\n                const ro = o.maxRandomnessOffset;\n                ops.push({ op: 'lineTo', data: [closePoint[0] + this.getOffset(-ro, ro, o), closePoint[1] + +this.getOffset(-ro, ro, o)] });\n            }\n        }\n        else if (len === 3) {\n            ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n            ops.push({\n                op: 'bcurveTo', data: [\n                    points[1][0], points[1][1],\n                    points[2][0], points[2][1],\n                    points[2][0], points[2][1]\n                ]\n            });\n        }\n        else if (len === 2) {\n            ops = ops.concat(this.doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n        }\n        return ops;\n    }\n    _ellipse(increment, cx, cy, rx, ry, offset, overlap, o) {\n        const radOffset = this.getOffset(-0.5, 0.5, o) - (Math.PI / 2);\n        const points = [];\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n        ]);\n        for (let angle = radOffset; angle < (Math.PI * 2 + radOffset - 0.01); angle = angle + increment) {\n            points.push([\n                this.getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n                this.getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n            ]);\n        }\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            this.getOffset(-offset, offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)\n        ]);\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            this.getOffset(-offset, offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)\n        ]);\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)\n        ]);\n        return this._curve(points, null, o);\n    }\n    _curveWithOffset(points, offset, o) {\n        const ps = [];\n        ps.push([\n            points[0][0] + this.getOffset(-offset, offset, o),\n            points[0][1] + this.getOffset(-offset, offset, o),\n        ]);\n        ps.push([\n            points[0][0] + this.getOffset(-offset, offset, o),\n            points[0][1] + this.getOffset(-offset, offset, o),\n        ]);\n        for (let i = 1; i < points.length; i++) {\n            ps.push([\n                points[i][0] + this.getOffset(-offset, offset, o),\n                points[i][1] + this.getOffset(-offset, offset, o),\n            ]);\n            if (i === (points.length - 1)) {\n                ps.push([\n                    points[i][0] + this.getOffset(-offset, offset, o),\n                    points[i][1] + this.getOffset(-offset, offset, o),\n                ]);\n            }\n        }\n        return this._curve(ps, null, o);\n    }\n    _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n        const radOffset = strt + this.getOffset(-0.1, 0.1, o);\n        const points = [];\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n        ]);\n        for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n            points.push([\n                this.getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n                this.getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n            ]);\n        }\n        points.push([\n            cx + rx * Math.cos(stp),\n            cy + ry * Math.sin(stp)\n        ]);\n        points.push([\n            cx + rx * Math.cos(stp),\n            cy + ry * Math.sin(stp)\n        ]);\n        return this._curve(points, null, o);\n    }\n    _bezierTo(x1, y1, x2, y2, x, y, path, o) {\n        const ops = [];\n        const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];\n        let f = [0, 0];\n        for (let i = 0; i < 2; i++) {\n            if (i === 0) {\n                ops.push({ op: 'move', data: [path.x, path.y] });\n            }\n            else {\n                ops.push({ op: 'move', data: [path.x + this.getOffset(-ros[0], ros[0], o), path.y + this.getOffset(-ros[0], ros[0], o)] });\n            }\n            f = [x + this.getOffset(-ros[i], ros[i], o), y + this.getOffset(-ros[i], ros[i], o)];\n            ops.push({\n                op: 'bcurveTo', data: [\n                    x1 + this.getOffset(-ros[i], ros[i], o), y1 + this.getOffset(-ros[i], ros[i], o),\n                    x2 + this.getOffset(-ros[i], ros[i], o), y2 + this.getOffset(-ros[i], ros[i], o),\n                    f[0], f[1]\n                ]\n            });\n        }\n        path.setPosition(f[0], f[1]);\n        return ops;\n    }\n    _processSegment(path, seg, prevSeg, o) {\n        let ops = [];\n        switch (seg.key) {\n            case 'M':\n            case 'm': {\n                const delta = seg.key === 'm';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    const ro = 1 * (o.maxRandomnessOffset || 0);\n                    x = x + this.getOffset(-ro, ro, o);\n                    y = y + this.getOffset(-ro, ro, o);\n                    path.setPosition(x, y);\n                    ops.push({ op: 'move', data: [x, y] });\n                }\n                break;\n            }\n            case 'L':\n            case 'l': {\n                const delta = seg.key === 'l';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, x, y, o));\n                    path.setPosition(x, y);\n                }\n                break;\n            }\n            case 'H':\n            case 'h': {\n                const delta = seg.key === 'h';\n                if (seg.data.length) {\n                    let x = +seg.data[0];\n                    if (delta) {\n                        x += path.x;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, x, path.y, o));\n                    path.setPosition(x, path.y);\n                }\n                break;\n            }\n            case 'V':\n            case 'v': {\n                const delta = seg.key === 'v';\n                if (seg.data.length) {\n                    let y = +seg.data[0];\n                    if (delta) {\n                        y += path.y;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, path.x, y, o));\n                    path.setPosition(path.x, y);\n                }\n                break;\n            }\n            case 'Z':\n            case 'z': {\n                if (path.first) {\n                    ops = ops.concat(this.doubleLine(path.x, path.y, path.first[0], path.first[1], o));\n                    path.setPosition(path.first[0], path.first[1]);\n                    path.first = null;\n                }\n                break;\n            }\n            case 'C':\n            case 'c': {\n                const delta = seg.key === 'c';\n                if (seg.data.length >= 6) {\n                    let x1 = +seg.data[0];\n                    let y1 = +seg.data[1];\n                    let x2 = +seg.data[2];\n                    let y2 = +seg.data[3];\n                    let x = +seg.data[4];\n                    let y = +seg.data[5];\n                    if (delta) {\n                        x1 += path.x;\n                        x2 += path.x;\n                        x += path.x;\n                        y1 += path.y;\n                        y2 += path.y;\n                        y += path.y;\n                    }\n                    const ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n                    ops = ops.concat(ob);\n                    path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n                }\n                break;\n            }\n            case 'S':\n            case 's': {\n                const delta = seg.key === 's';\n                if (seg.data.length >= 4) {\n                    let x2 = +seg.data[0];\n                    let y2 = +seg.data[1];\n                    let x = +seg.data[2];\n                    let y = +seg.data[3];\n                    if (delta) {\n                        x2 += path.x;\n                        x += path.x;\n                        y2 += path.y;\n                        y += path.y;\n                    }\n                    let x1 = x2;\n                    let y1 = y2;\n                    const prevKey = prevSeg ? prevSeg.key : '';\n                    let ref = null;\n                    if (prevKey === 'c' || prevKey === 'C' || prevKey === 's' || prevKey === 'S') {\n                        ref = path.bezierReflectionPoint;\n                    }\n                    if (ref) {\n                        x1 = ref[0];\n                        y1 = ref[1];\n                    }\n                    const ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n                    ops = ops.concat(ob);\n                    path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n                }\n                break;\n            }\n            case 'Q':\n            case 'q': {\n                const delta = seg.key === 'q';\n                if (seg.data.length >= 4) {\n                    let x1 = +seg.data[0];\n                    let y1 = +seg.data[1];\n                    let x = +seg.data[2];\n                    let y = +seg.data[3];\n                    if (delta) {\n                        x1 += path.x;\n                        x += path.x;\n                        y1 += path.y;\n                        y += path.y;\n                    }\n                    const offset1 = 1 * (1 + o.roughness * 0.2);\n                    const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset1, offset1, o), path.y + this.getOffset(-offset1, offset1, o)] });\n                    let f = [x + this.getOffset(-offset1, offset1, o), y + this.getOffset(-offset1, offset1, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset1, offset1, o), y1 + this.getOffset(-offset1, offset1, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset2, offset2, o), path.y + this.getOffset(-offset2, offset2, o)] });\n                    f = [x + this.getOffset(-offset2, offset2, o), y + this.getOffset(-offset2, offset2, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset2, offset2, o), y1 + this.getOffset(-offset2, offset2, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    path.setPosition(f[0], f[1]);\n                    path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n                }\n                break;\n            }\n            case 'T':\n            case 't': {\n                const delta = seg.key === 't';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    let x1 = x;\n                    let y1 = y;\n                    const prevKey = prevSeg ? prevSeg.key : '';\n                    let ref = null;\n                    if (prevKey === 'q' || prevKey === 'Q' || prevKey === 't' || prevKey === 'T') {\n                        ref = path.quadReflectionPoint;\n                    }\n                    if (ref) {\n                        x1 = ref[0];\n                        y1 = ref[1];\n                    }\n                    const offset1 = 1 * (1 + o.roughness * 0.2);\n                    const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset1, offset1, o), path.y + this.getOffset(-offset1, offset1, o)] });\n                    let f = [x + this.getOffset(-offset1, offset1, o), y + this.getOffset(-offset1, offset1, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset1, offset1, o), y1 + this.getOffset(-offset1, offset1, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset2, offset2, o), path.y + this.getOffset(-offset2, offset2, o)] });\n                    f = [x + this.getOffset(-offset2, offset2, o), y + this.getOffset(-offset2, offset2, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset2, offset2, o), y1 + this.getOffset(-offset2, offset2, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    path.setPosition(f[0], f[1]);\n                    path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n                }\n                break;\n            }\n            case 'A':\n            case 'a': {\n                const delta = seg.key === 'a';\n                if (seg.data.length >= 7) {\n                    const rx = +seg.data[0];\n                    const ry = +seg.data[1];\n                    const angle = +seg.data[2];\n                    const largeArcFlag = +seg.data[3];\n                    const sweepFlag = +seg.data[4];\n                    let x = +seg.data[5];\n                    let y = +seg.data[6];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    if (x === path.x && y === path.y) {\n                        break;\n                    }\n                    if (rx === 0 || ry === 0) {\n                        ops = ops.concat(this.doubleLine(path.x, path.y, x, y, o));\n                        path.setPosition(x, y);\n                    }\n                    else {\n                        for (let i = 0; i < 1; i++) {\n                            const arcConverter = new RoughArcConverter([path.x, path.y], [x, y], [rx, ry], angle, largeArcFlag ? true : false, sweepFlag ? true : false);\n                            let segment = arcConverter.getNextSegment();\n                            while (segment) {\n                                const ob = this._bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);\n                                ops = ops.concat(ob);\n                                segment = arcConverter.getNextSegment();\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n            default:\n                break;\n        }\n        return ops;\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasSelf = typeof self !== 'undefined';\nconst roughScript = hasSelf && self && self.document && self.document.currentScript && self.document.currentScript.src;\nexport function createRenderer(config) {\n    if (hasSelf && roughScript && self && self.workly && config.async && (!config.noWorker)) {\n        const worklySource = config.worklyURL || 'https://cdn.jsdelivr.net/gh/pshihn/workly/dist/workly.min.js';\n        if (worklySource) {\n            const code = `importScripts('${worklySource}', '${roughScript}');\\nworkly.expose(self.rough.createRenderer());`;\n            const ourl = URL.createObjectURL(new Blob([code]));\n            return self.workly.proxy(ourl);\n        }\n    }\n    return new RoughRenderer();\n}\n","import { createRenderer } from './renderer-factory.js';\nconst hasSelf = typeof self !== 'undefined';\nexport class RoughGeneratorBase {\n    constructor(config, surface) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1\n        };\n        this.config = config || {};\n        this.surface = surface;\n        this.renderer = createRenderer(this.config);\n        if (this.config.options) {\n            this.defaultOptions = this._options(this.config.options);\n        }\n    }\n    _options(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _drawable(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    get lib() {\n        return this.renderer;\n    }\n    getCanvasSize() {\n        const val = (w) => {\n            if (w && typeof w === 'object') {\n                if (w.baseVal && w.baseVal.value) {\n                    return w.baseVal.value;\n                }\n            }\n            return w || 100;\n        };\n        if (this.surface) {\n            return [val(this.surface.width), val(this.surface.height)];\n        }\n        return [100, 100];\n    }\n    computePolygonSize(points) {\n        if (points.length) {\n            let left = points[0][0];\n            let right = points[0][0];\n            let top = points[0][1];\n            let bottom = points[0][1];\n            for (let i = 1; i < points.length; i++) {\n                left = Math.min(left, points[i][0]);\n                right = Math.max(right, points[i][0]);\n                top = Math.min(top, points[i][1]);\n                bottom = Math.max(bottom, points[i][1]);\n            }\n            return [(right - left), (bottom - top)];\n        }\n        return [0, 0];\n    }\n    polygonPath(points) {\n        let d = '';\n        if (points.length) {\n            d = `M${points[0][0]},${points[0][1]}`;\n            for (let i = 1; i < points.length; i++) {\n                d = `${d} L${points[i][0]},${points[i][1]}`;\n            }\n        }\n        return d;\n    }\n    computePathSize(d) {\n        let size = [0, 0];\n        if (hasSelf && self.document) {\n            try {\n                const ns = 'http://www.w3.org/2000/svg';\n                const svg = self.document.createElementNS(ns, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(ns, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                self.document.body.appendChild(svg);\n                const bb = pathNode.getBBox();\n                if (bb) {\n                    size[0] = bb.width || 0;\n                    size[1] = bb.height || 0;\n                }\n                self.document.body.removeChild(svg);\n            }\n            catch (err) { }\n        }\n        const canvasSize = this.getCanvasSize();\n        if (!(size[0] * size[1])) {\n            size = canvasSize;\n        }\n        return size;\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: 'none'\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        fill: o.fill || 'none'\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n                case 'path2Dfill':\n                    path = {\n                        d: drawing.path || '',\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        fill: o.fill || 'none'\n                    };\n                    break;\n                case 'path2Dpattern': {\n                    const size = drawing.size;\n                    const pattern = {\n                        x: 0, y: 0, width: 1, height: 1,\n                        viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n                        patternUnits: 'objectBoundingBox',\n                        path: this.fillSketch(drawing, o)\n                    };\n                    path = {\n                        d: drawing.path,\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        pattern: pattern\n                    };\n                    break;\n                }\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || 'none',\n            strokeWidth: fweight,\n            fill: 'none'\n        };\n    }\n    opsToPath(drawing) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'qcurveTo':\n                    path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n}\n","import { RoughGeneratorBase } from './generator-base';\nexport class RoughGenerator extends RoughGeneratorBase {\n    constructor(config, surface) {\n        super(config, surface);\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [this.lib.line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(this.lib.patternFillPolygon(points, o));\n            }\n        }\n        paths.push(this.lib.rectangle(x, y, width, height, o));\n        return this._drawable('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = this.lib.ellipse(x, y, width, height, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(this.lib.patternFillEllipse(x, y, width, height, o));\n            }\n        }\n        paths.push(this.lib.ellipse(x, y, width, height, o));\n        return this._drawable('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [this.lib.linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = this.lib.arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(this.lib.patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        paths.push(this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n        return this._drawable('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [this.lib.curve(points, o)], o);\n    }\n    polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                const size = this.computePolygonSize(points);\n                const fillPoints = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = this.lib.patternFillPolygon(fillPoints, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = this.polygonPath(points);\n                paths.push(shape);\n            }\n        }\n        paths.push(this.lib.linearPath(points, true, o));\n        return this._drawable('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = this.lib.patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        paths.push(this.lib.svgPath(d, o));\n        return this._drawable('path', paths, o);\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughCanvasBase {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n    }\n    static createRenderer() {\n        return new RoughRenderer();\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillPath':\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n                case 'path2Dfill': {\n                    this.ctx.save();\n                    this.ctx.fillStyle = o.fill || '';\n                    const p2d = new Path2D(drawing.path);\n                    this.ctx.fill(p2d);\n                    this.ctx.restore();\n                    break;\n                }\n                case 'path2Dpattern': {\n                    const doc = this.canvas.ownerDocument || (hasDocument && document);\n                    if (doc) {\n                        const size = drawing.size;\n                        const hcanvas = doc.createElement('canvas');\n                        const hcontext = hcanvas.getContext('2d');\n                        const bbox = this.computeBBox(drawing.path);\n                        if (bbox && (bbox.width || bbox.height)) {\n                            hcanvas.width = this.canvas.width;\n                            hcanvas.height = this.canvas.height;\n                            hcontext.translate(bbox.x || 0, bbox.y || 0);\n                        }\n                        else {\n                            hcanvas.width = size[0];\n                            hcanvas.height = size[1];\n                        }\n                        this.fillSketch(hcontext, drawing, o);\n                        this.ctx.save();\n                        this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n                        const p2d = new Path2D(drawing.path);\n                        this.ctx.fill(p2d);\n                        this.ctx.restore();\n                    }\n                    else {\n                        console.error('Cannot render path2Dpattern. No defs/document defined.');\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    computeBBox(d) {\n        if (hasDocument) {\n            try {\n                const ns = 'http://www.w3.org/2000/svg';\n                const svg = document.createElementNS(ns, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(ns, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                document.body.appendChild(svg);\n                const bbox = pathNode.getBBox();\n                document.body.removeChild(svg);\n                return bbox;\n            }\n            catch (err) { }\n        }\n        return null;\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing) {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'qcurveTo':\n                    ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill();\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n}\n","import { RoughGenerator } from './generator';\nimport { RoughCanvasBase } from './canvas-base';\nexport class RoughCanvas extends RoughCanvasBase {\n    constructor(canvas, config) {\n        super(canvas);\n        this.gen = new RoughGenerator(config || null, this.canvas);\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","import { RoughGeneratorBase } from './generator-base';\nexport class RoughGeneratorAsync extends RoughGeneratorBase {\n    async line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [await this.lib.line(x1, y1, x2, y2, o)], o);\n    }\n    async rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(await this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(await this.lib.patternFillPolygon(points, o));\n            }\n        }\n        paths.push(await this.lib.rectangle(x, y, width, height, o));\n        return this._drawable('rectangle', paths, o);\n    }\n    async ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = await this.lib.ellipse(x, y, width, height, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(await this.lib.patternFillEllipse(x, y, width, height, o));\n            }\n        }\n        paths.push(await this.lib.ellipse(x, y, width, height, o));\n        return this._drawable('ellipse', paths, o);\n    }\n    async circle(x, y, diameter, options) {\n        const ret = await this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    async linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [await this.lib.linearPath(points, false, o)], o);\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = await this.lib.arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(await this.lib.patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        paths.push(await this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n        return this._drawable('arc', paths, o);\n    }\n    async curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [await this.lib.curve(points, o)], o);\n    }\n    async polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(await this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                const size = this.computePolygonSize(points);\n                const fillPoints = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = await this.lib.patternFillPolygon(fillPoints, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = this.polygonPath(points);\n                paths.push(shape);\n            }\n        }\n        paths.push(await this.lib.linearPath(points, true, o));\n        return this._drawable('polygon', paths, o);\n    }\n    async path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = await this.lib.patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        paths.push(await this.lib.svgPath(d, o));\n        return this._drawable('path', paths, o);\n    }\n}\n","import { RoughGeneratorAsync } from './generator-async';\nimport { RoughCanvasBase } from './canvas-base';\nexport class RoughCanvasAsync extends RoughCanvasBase {\n    constructor(canvas, config) {\n        super(canvas);\n        this.genAsync = new RoughGeneratorAsync(config || null, this.canvas);\n    }\n    get generator() {\n        return this.genAsync;\n    }\n    getDefaultOptions() {\n        return this.genAsync.defaultOptions;\n    }\n    async line(x1, y1, x2, y2, options) {\n        const d = await this.genAsync.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    async rectangle(x, y, width, height, options) {\n        const d = await this.genAsync.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    async ellipse(x, y, width, height, options) {\n        const d = await this.genAsync.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    async circle(x, y, diameter, options) {\n        const d = await this.genAsync.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    async linearPath(points, options) {\n        const d = await this.genAsync.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    async polygon(points, options) {\n        const d = await this.genAsync.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = await this.genAsync.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    async curve(points, options) {\n        const d = await this.genAsync.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    async path(d, options) {\n        const drawing = await this.genAsync.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughSVGBase {\n    constructor(svg) {\n        this.svg = svg;\n    }\n    static createRenderer() {\n        return new RoughRenderer();\n    }\n    get defs() {\n        const doc = this.svg.ownerDocument || (hasDocument && document);\n        if (doc) {\n            if (!this._defs) {\n                const dnode = doc.createElementNS('http://www.w3.org/2000/svg', 'defs');\n                if (this.svg.firstChild) {\n                    this.svg.insertBefore(dnode, this.svg.firstChild);\n                }\n                else {\n                    this.svg.appendChild(dnode);\n                }\n                this._defs = dnode;\n            }\n        }\n        return this._defs || null;\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || (hasDocument && document);\n        const g = doc.createElementNS('http://www.w3.org/2000/svg', 'g');\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                    path.setAttribute('d', this.opsToPath(drawing));\n                    path.style.stroke = o.stroke;\n                    path.style.strokeWidth = o.strokeWidth + '';\n                    path.style.fill = 'none';\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                    path.setAttribute('d', this.opsToPath(drawing));\n                    path.style.stroke = 'none';\n                    path.style.strokeWidth = '0';\n                    path.style.fill = o.fill || null;\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n                case 'path2Dfill': {\n                    path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                    path.setAttribute('d', drawing.path || '');\n                    path.style.stroke = 'none';\n                    path.style.strokeWidth = '0';\n                    path.style.fill = o.fill || null;\n                    break;\n                }\n                case 'path2Dpattern': {\n                    if (!this.defs) {\n                        console.error('Cannot render path2Dpattern. No defs/document defined.');\n                    }\n                    else {\n                        const size = drawing.size;\n                        const pattern = doc.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n                        const id = `rough-${Math.floor(Math.random() * (Number.MAX_SAFE_INTEGER || 999999))}`;\n                        pattern.setAttribute('id', id);\n                        pattern.setAttribute('x', '0');\n                        pattern.setAttribute('y', '0');\n                        pattern.setAttribute('width', '1');\n                        pattern.setAttribute('height', '1');\n                        pattern.setAttribute('height', '1');\n                        pattern.setAttribute('viewBox', `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`);\n                        pattern.setAttribute('patternUnits', 'objectBoundingBox');\n                        const patternPath = this.fillSketch(doc, drawing, o);\n                        pattern.appendChild(patternPath);\n                        this.defs.appendChild(pattern);\n                        path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                        path.setAttribute('d', drawing.path || '');\n                        path.style.stroke = 'none';\n                        path.style.strokeWidth = '0';\n                        path.style.fill = `url(#${id})`;\n                    }\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n        path.setAttribute('d', this.opsToPath(drawing));\n        path.style.stroke = o.fill || null;\n        path.style.strokeWidth = fweight + '';\n        path.style.fill = 'none';\n        return path;\n    }\n}\n","import { RoughGenerator } from './generator';\nimport { RoughSVGBase } from './svg-base';\nexport class RoughSVG extends RoughSVGBase {\n    constructor(svg, config) {\n        super(svg);\n        this.gen = new RoughGenerator(config || null, this.svg);\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing) {\n        return this.gen.opsToPath(drawing);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n","import { RoughGeneratorAsync } from './generator-async';\nimport { RoughSVGBase } from './svg-base';\nexport class RoughSVGAsync extends RoughSVGBase {\n    constructor(svg, config) {\n        super(svg);\n        this.genAsync = new RoughGeneratorAsync(config || null, this.svg);\n    }\n    get generator() {\n        return this.genAsync;\n    }\n    getDefaultOptions() {\n        return this.genAsync.defaultOptions;\n    }\n    opsToPath(drawing) {\n        return this.genAsync.opsToPath(drawing);\n    }\n    async line(x1, y1, x2, y2, options) {\n        const d = await this.genAsync.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    async rectangle(x, y, width, height, options) {\n        const d = await this.genAsync.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    async ellipse(x, y, width, height, options) {\n        const d = await this.genAsync.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    async circle(x, y, diameter, options) {\n        const d = await this.genAsync.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    async linearPath(points, options) {\n        const d = await this.genAsync.linearPath(points, options);\n        return this.draw(d);\n    }\n    async polygon(points, options) {\n        const d = await this.genAsync.polygon(points, options);\n        return this.draw(d);\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = await this.genAsync.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    async curve(points, options) {\n        const d = await this.genAsync.curve(points, options);\n        return this.draw(d);\n    }\n    async path(d, options) {\n        const drawing = await this.genAsync.path(d, options);\n        return this.draw(drawing);\n    }\n}\n","import { RoughCanvas } from './canvas';\nimport { RoughGenerator } from './generator';\nimport { RoughGeneratorAsync } from './generator-async';\nimport { RoughCanvasAsync } from './canvas-async';\nimport { RoughSVG } from './svg';\nimport { RoughSVGAsync } from './svg-async';\nexport default {\n    canvas(canvas, config) {\n        if (config && config.async) {\n            return new RoughCanvasAsync(canvas, config);\n        }\n        return new RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        if (config && config.async) {\n            return new RoughSVGAsync(svg, config);\n        }\n        return new RoughSVG(svg, config);\n    },\n    createRenderer() {\n        return RoughCanvas.createRenderer();\n    },\n    generator(config, surface) {\n        if (config && config.async) {\n            return new RoughGeneratorAsync(config, surface);\n        }\n        return new RoughGenerator(config, surface);\n    }\n};\n","/**\n * Copyright 2014 Google Inc. All rights reserved.\n *\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n *\n * @fileoverview Description of this file.\n *\n * A polyfill for HTML Canvas features, including\n * Path2D support.\n */\n\n(function (CanvasRenderingContext2D, nodeRequire) {\n\nif (CanvasRenderingContext2D == undefined) {\n  CanvasRenderingContext2D = nodeRequire('canvas').Context2d;\n}\n\nif (CanvasRenderingContext2D.prototype.ellipse == undefined) {\n  CanvasRenderingContext2D.prototype.ellipse = function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n    this.save();\n    this.translate(x, y);\n    this.rotate(rotation);\n    this.scale(radiusX, radiusY);\n    this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n    this.restore();\n  }\n}\n\nif (typeof Path2D !== 'function' || \n    typeof new Path2D().addPath !== 'function') {\n  (function() {\n\n    // Include the SVG path parser.\n    parser = (function() {\n      /*\n       * Generated by PEG.js 0.8.0.\n       *\n       * http://pegjs.majda.cz/\n       */\n    \n      function peg$subclass(child, parent) {\n        function ctor() { this.constructor = child; }\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n    \n      function SyntaxError(message, expected, found, offset, line, column) {\n        this.message  = message;\n        this.expected = expected;\n        this.found    = found;\n        this.offset   = offset;\n        this.line     = line;\n        this.column   = column;\n    \n        this.name     = \"SyntaxError\";\n      }\n    \n      peg$subclass(SyntaxError, Error);\n    \n      function parse(input) {\n        var options = arguments.length > 1 ? arguments[1] : {},\n    \n            peg$FAILED = {},\n    \n            peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n            peg$startRuleFunction  = peg$parsesvg_path,\n    \n            peg$c0 = peg$FAILED,\n            peg$c1 = [],\n            peg$c2 = null,\n            peg$c3 = function(d) { return ops; },\n            peg$c4 = /^[Mm]/,\n            peg$c5 = { type: \"class\", value: \"[Mm]\", description: \"[Mm]\" },\n            peg$c6 = function(ch, args) {\n                  var moveCh = ch\n                  // If this is the first move cmd then force it to be absolute.\n                  if (firstSubPath) {\n                    moveCh = 'M';\n                    firstSubPath = false;\n                  }\n                  ops.push({type: 'moveTo', args: makeAbsolute(moveCh, args[0])});\n                  for (var i=1; i < args.length; i++) {\n                    // The lineTo args are either abs or relative, depending on the\n                    // original moveto command.\n                    ops.push({type: 'lineTo', args: makeAbsolute(ch, args[i])});\n                  }\n                },\n            peg$c7 = function(one, rest) { return concatSequence(one, rest); },\n            peg$c8 = /^[Zz]/,\n            peg$c9 = { type: \"class\", value: \"[Zz]\", description: \"[Zz]\" },\n            peg$c10 = function() { ops.push({type: 'closePath', args: []}); },\n            peg$c11 = /^[Ll]/,\n            peg$c12 = { type: \"class\", value: \"[Ll]\", description: \"[Ll]\" },\n            peg$c13 = function(ch, args) {\n                  for (var i=0; i < args.length; i++) {\n                    ops.push({type: 'lineTo', args: makeAbsolute(ch, args[i])});\n                  }\n                },\n            peg$c14 = /^[Hh]/,\n            peg$c15 = { type: \"class\", value: \"[Hh]\", description: \"[Hh]\" },\n            peg$c16 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'lineTo', args: makeAbsoluteFromX(ch, args[i])});\n                }\n              },\n            peg$c17 = /^[Vv]/,\n            peg$c18 = { type: \"class\", value: \"[Vv]\", description: \"[Vv]\" },\n            peg$c19 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'lineTo', args: makeAbsoluteFromY(ch, args[i])});\n                }\n              },\n            peg$c20 = /^[Cc]/,\n            peg$c21 = { type: \"class\", value: \"[Cc]\", description: \"[Cc]\" },\n            peg$c22 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'bezierCurveTo', args: makeAbsoluteMultiple(ch, args[i])});\n                }\n              },\n            peg$c23 = function(cp1, cp2, last) { return cp1.concat(cp2, last); },\n            peg$c24 = /^[Ss]/,\n            peg$c25 = { type: \"class\", value: \"[Ss]\", description: \"[Ss]\" },\n            peg$c26 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'bezierCurveTo', args: makeReflected().concat(makeAbsoluteMultiple(ch, args[i]))});\n                }\n              },\n            peg$c27 = function(cp1, last) { return cp1.concat(last); },\n            peg$c28 = /^[Qq]/,\n            peg$c29 = { type: \"class\", value: \"[Qq]\", description: \"[Qq]\" },\n            peg$c30 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  ops.push({type: 'quadraticCurveTo', args: makeAbsoluteMultiple(ch, args[i])});\n                }\n              },\n            peg$c31 = /^[Tt]/,\n            peg$c32 = { type: \"class\", value: \"[Tt]\", description: \"[Tt]\" },\n            peg$c33 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  var reflected = makeReflected();\n                  ops.push({type: 'quadraticCurveTo', args: reflected.concat(makeAbsoluteMultiple(ch, args[i]))});\n                  lastControl = reflected.slice(0);\n                }\n              },\n            peg$c34 = /^[Aa]/,\n            peg$c35 = { type: \"class\", value: \"[Aa]\", description: \"[Aa]\" },\n            peg$c36 = function(ch, args) {\n                for (var i=0; i < args.length; i++) {\n                  var x1 = [lastCoord.slice()];\n                  var x2 = [makeAbsolute(ch, args[i].slice(-2))];\n                  absArgs = x1.concat(args[i].slice(0, -2), x2);\n                  ellipseFromEllipticalArc.apply(this, absArgs);\n                }\n              },\n            peg$c37 = function(rx, ry, xrot, large, sweep, last) { return [parseFloat(rx), parseFloat(ry), parseFloat(flatten(xrot).join('')), parseInt(large), parseInt(sweep), last[0], last[1]]; },\n            peg$c38 = function(x, y) { return [x, y] },\n            peg$c39 = function(number) { return parseFloat(flatten(number).join('')) },\n            peg$c40 = \"0\",\n            peg$c41 = { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n            peg$c42 = \"1\",\n            peg$c43 = { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n            peg$c44 = \",\",\n            peg$c45 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n            peg$c46 = \".\",\n            peg$c47 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n            peg$c48 = /^[eE]/,\n            peg$c49 = { type: \"class\", value: \"[eE]\", description: \"[eE]\" },\n            peg$c50 = \"+\",\n            peg$c51 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n            peg$c52 = \"-\",\n            peg$c53 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n            peg$c54 = /^[0-9]/,\n            peg$c55 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n            peg$c56 = function(digits) { return digits.join('') },\n            peg$c57 = /^[ \\t\\n\\r]/,\n            peg$c58 = { type: \"class\", value: \"[ \\\\t\\\\n\\\\r]\", description: \"[ \\\\t\\\\n\\\\r]\" },\n    \n            peg$currPos          = 0,\n            peg$reportedPos      = 0,\n            peg$cachedPos        = 0,\n            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n            peg$maxFailPos       = 0,\n            peg$maxFailExpected  = [],\n            peg$silentFails      = 0,\n    \n            peg$result;\n    \n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n    \n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n    \n        function text() {\n          return input.substring(peg$reportedPos, peg$currPos);\n        }\n    \n        function offset() {\n          return peg$reportedPos;\n        }\n    \n        function line() {\n          return peg$computePosDetails(peg$reportedPos).line;\n        }\n    \n        function column() {\n          return peg$computePosDetails(peg$reportedPos).column;\n        }\n    \n        function expected(description) {\n          throw peg$buildException(\n            null,\n            [{ type: \"other\", description: description }],\n            peg$reportedPos\n          );\n        }\n    \n        function error(message) {\n          throw peg$buildException(message, null, peg$reportedPos);\n        }\n    \n        function peg$computePosDetails(pos) {\n          function advance(details, startPos, endPos) {\n            var p, ch;\n    \n            for (p = startPos; p < endPos; p++) {\n              ch = input.charAt(p);\n              if (ch === \"\\n\") {\n                if (!details.seenCR) { details.line++; }\n                details.column = 1;\n                details.seenCR = false;\n              } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n                details.line++;\n                details.column = 1;\n                details.seenCR = true;\n              } else {\n                details.column++;\n                details.seenCR = false;\n              }\n            }\n          }\n    \n          if (peg$cachedPos !== pos) {\n            if (peg$cachedPos > pos) {\n              peg$cachedPos = 0;\n              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n            }\n            advance(peg$cachedPosDetails, peg$cachedPos, pos);\n            peg$cachedPos = pos;\n          }\n    \n          return peg$cachedPosDetails;\n        }\n    \n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) { return; }\n    \n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n    \n          peg$maxFailExpected.push(expected);\n        }\n    \n        function peg$buildException(message, expected, pos) {\n          function cleanupExpected(expected) {\n            var i = 1;\n    \n            expected.sort(function(a, b) {\n              if (a.description < b.description) {\n                return -1;\n              } else if (a.description > b.description) {\n                return 1;\n              } else {\n                return 0;\n              }\n            });\n    \n            while (i < expected.length) {\n              if (expected[i - 1] === expected[i]) {\n                expected.splice(i, 1);\n              } else {\n                i++;\n              }\n            }\n          }\n    \n          function buildMessage(expected, found) {\n            function stringEscape(s) {\n              function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n    \n              return s\n                .replace(/\\\\/g,   '\\\\\\\\')\n                .replace(/\"/g,    '\\\\\"')\n                .replace(/\\x08/g, '\\\\b')\n                .replace(/\\t/g,   '\\\\t')\n                .replace(/\\n/g,   '\\\\n')\n                .replace(/\\f/g,   '\\\\f')\n                .replace(/\\r/g,   '\\\\r')\n                .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n                .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n                .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n                .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n            }\n    \n            var expectedDescs = new Array(expected.length),\n                expectedDesc, foundDesc, i;\n    \n            for (i = 0; i < expected.length; i++) {\n              expectedDescs[i] = expected[i].description;\n            }\n    \n            expectedDesc = expected.length > 1\n              ? expectedDescs.slice(0, -1).join(\", \")\n                  + \" or \"\n                  + expectedDescs[expected.length - 1]\n              : expectedDescs[0];\n    \n            foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n    \n            return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n          }\n    \n          var posDetails = peg$computePosDetails(pos),\n              found      = pos < input.length ? input.charAt(pos) : null;\n    \n          if (expected !== null) {\n            cleanupExpected(expected);\n          }\n    \n          return new SyntaxError(\n            message !== null ? message : buildMessage(expected, found),\n            expected,\n            found,\n            pos,\n            posDetails.line,\n            posDetails.column\n          );\n        }\n    \n        function peg$parsesvg_path() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewsp();\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsewsp();\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsemoveTo_drawTo_commandGroups();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsewsp();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsewsp();\n              }\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c3(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveTo_drawTo_commandGroups() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parsewsp();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsewsp();\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsemoveTo_drawTo_commandGroups();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveTo_drawTo_commandGroup() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsemoveto();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parsewsp();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsewsp();\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsedrawto_commands();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsedrawto_commands() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsedrawto_command();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parsewsp();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parsewsp();\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsedrawto_commands();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsedrawto_command() {\n          var s0;\n    \n          s0 = peg$parseclosepath();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parselineto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsehorizontal_lineto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsevertical_lineto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsecurveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsesmooth_curveto();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsequadratic_bezier_curveto();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parseelliptical_arc();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsemoveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c6(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsemoveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parselineto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseclosepath() {\n          var s0, s1;\n    \n          s0 = peg$currPos;\n          if (peg$c8.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c9); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c10();\n          }\n          s0 = s1;\n    \n          return s0;\n        }\n    \n        function peg$parselineto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c11.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c12); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parselineto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c13(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parselineto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parselineto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsehorizontal_lineto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c14.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c16(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecoordinate_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsecoordinate_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsevertical_lineto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c19(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecurveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecurveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c22(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecurveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecurveto_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsecurveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecurveto_argument() {\n          var s0, s1, s2, s3, s4, s5;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_pair();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parsecomma_wsp();\n                if (s4 === peg$FAILED) {\n                  s4 = peg$c2;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsecoordinate_pair();\n                  if (s5 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c23(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_curveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c24.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c25); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsesmooth_curveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c26(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_curveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsesmooth_curveto_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsesmooth_curveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_curveto_argument() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_pair();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c27(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsequadratic_bezier_curveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c28.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c30(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsequadratic_bezier_curveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsequadratic_bezier_curveto_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsequadratic_bezier_curveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsequadratic_bezier_curveto_argument() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate_pair();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c27(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_quadratic_bezier_curveto() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c31.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c33(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate_pair();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseelliptical_arc() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c34.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c35); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewsp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewsp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseelliptical_arc_argument_sequence();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c36(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseelliptical_arc_argument_sequence() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = peg$parseelliptical_arc_argument();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$parsecomma_wsp();\n            if (s3 === peg$FAILED) {\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseelliptical_arc_argument_sequence();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c0;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c7(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseelliptical_arc_argument() {\n          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsenonnegative_number();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsenonnegative_number();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parsecomma_wsp();\n                if (s4 === peg$FAILED) {\n                  s4 = peg$c2;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsecomma_wsp();\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parseflag();\n                      if (s7 !== peg$FAILED) {\n                        s8 = peg$parsecomma_wsp();\n                        if (s8 === peg$FAILED) {\n                          s8 = peg$c2;\n                        }\n                        if (s8 !== peg$FAILED) {\n                          s9 = peg$parseflag();\n                          if (s9 !== peg$FAILED) {\n                            s10 = peg$parsecomma_wsp();\n                            if (s10 === peg$FAILED) {\n                              s10 = peg$c2;\n                            }\n                            if (s10 !== peg$FAILED) {\n                              s11 = peg$parsecoordinate_pair();\n                              if (s11 !== peg$FAILED) {\n                                peg$reportedPos = s0;\n                                s1 = peg$c37(s1, s3, s5, s7, s9, s11);\n                                s0 = s1;\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$c0;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecoordinate_pair() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsecoordinate();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma_wsp();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecoordinate();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c38(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecoordinate() {\n          var s0, s1;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsenumber();\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c39(s1);\n          }\n          s0 = s1;\n    \n          return s0;\n        }\n    \n        function peg$parsenonnegative_number() {\n          var s0;\n    \n          s0 = peg$parsefloating_point_constant();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsedigit_sequence();\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsenumber() {\n          var s0, s1, s2;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsesign();\n          if (s1 === peg$FAILED) {\n            s1 = peg$c2;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsefloating_point_constant();\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsesign();\n            if (s1 === peg$FAILED) {\n              s1 = peg$c2;\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsedigit_sequence();\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseflag() {\n          var s0;\n    \n          if (input.charCodeAt(peg$currPos) === 48) {\n            s0 = peg$c40;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c41); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 49) {\n              s0 = peg$c42;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecomma_wsp() {\n          var s0, s1, s2, s3, s4;\n    \n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewsp();\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsewsp();\n            }\n          } else {\n            s1 = peg$c0;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecomma();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsewsp();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsewsp();\n              }\n              if (s3 !== peg$FAILED) {\n                s1 = [s1, s2, s3];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecomma();\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$parsewsp();\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parsewsp();\n              }\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsecomma() {\n          var s0;\n    \n          if (input.charCodeAt(peg$currPos) === 44) {\n            s0 = peg$c44;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c45); }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsefloating_point_constant() {\n          var s0, s1, s2;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsefractional_constant();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseexponent();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsedigit_sequence();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseexponent();\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsefractional_constant() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          s1 = peg$parsedigit_sequence();\n          if (s1 === peg$FAILED) {\n            s1 = peg$c2;\n          }\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s2 = peg$c46;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c47); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsedigit_sequence();\n              if (s3 !== peg$FAILED) {\n                s1 = [s1, s2, s3];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsedigit_sequence();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s2 = peg$c46;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c47); }\n              }\n              if (s2 !== peg$FAILED) {\n                s1 = [s1, s2];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parseexponent() {\n          var s0, s1, s2, s3;\n    \n          s0 = peg$currPos;\n          if (peg$c48.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsesign();\n            if (s2 === peg$FAILED) {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsedigit_sequence();\n              if (s3 !== peg$FAILED) {\n                s1 = [s1, s2, s3];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsesign() {\n          var s0;\n    \n          if (input.charCodeAt(peg$currPos) === 43) {\n            s0 = peg$c50;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s0 = peg$c52;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n          }\n    \n          return s0;\n        }\n    \n        function peg$parsedigit_sequence() {\n          var s0, s1, s2;\n    \n          s0 = peg$currPos;\n          s1 = [];\n          if (peg$c54.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c55); }\n          }\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              if (peg$c54.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c55); }\n              }\n            }\n          } else {\n            s1 = peg$c0;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c56(s1);\n          }\n          s0 = s1;\n    \n          return s0;\n        }\n    \n        function peg$parsewsp() {\n          var s0;\n    \n          if (peg$c57.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c58); }\n          }\n    \n          return s0;\n        }\n    \n    \n          // The last coordinate we are at in the path. In absolute coords.\n          var lastCoord = [0, 0];\n          // The last control point we encountered in the path. In absolute coords.\n          var lastControl = [0, 0];\n          // The list of operations we've parsed so far.\n          var ops = [];\n          // Have we parsed the first sub-path yet?\n          var firstSubPath = true;\n          // The letter of the last parsed command.\n          var lastCh = '';\n    \n          // Flatten an array.\n          function flatten(a) {\n            var flat = [];\n            for (var i = 0; i < a.length; i++) {\n              if (a[i] instanceof Array) {\n                flat.push.apply(flat, flatten(a[i]));\n              } else {\n                flat.push(a[i]);\n              }\n            }\n            return flat;\n          }\n    \n          // Convert a position into an absolute position.\n          function makeAbsolute(c, coord) {\n            if ('mlazhvcsqt'.indexOf(c) === -1) {\n              lastCoord = coord;\n            } else {\n              lastCoord[0] += coord[0];\n              lastCoord[1] += coord[1];\n            }\n            lastCh = c;\n            return lastCoord.slice(0);\n          }\n    \n          // Convert a sequence of coordinates into absolute coordinates.\n          //\n          // For arguments that take multiple coord pairs, such as bezier.\n          function makeAbsoluteMultiple(c, seq) {\n            var r = [];\n            var lastPosCopy = lastCoord.slice(0);\n            for (var i=0; i < seq.length; i+=2) {\n              // Only the last point should update lastCoord.\n              lastCoord = lastPosCopy.slice(0);\n              var coord = makeAbsolute(c, seq.slice(i, i+2));\n              r = r.concat(coord);\n              // Record the last control point, it might be needed for\n              // shorthand operations.\n              if (i == seq.length-4) {\n                lastControl = coord.slice(0);\n              }\n            }\n            return r;\n          }\n    \n          // Find the reflection of the last control point over\n          // the last postion in the path.\n          function makeReflected() {\n            if ('CcSsQqTt'.indexOf(lastCh) == -1) {\n              lastControl = lastCoord.slice(0);\n            }\n            // reflected = 2*lastCoord - lastControl\n            // Note the result is absolute, not relative.\n            var r = [0, 0];\n            r[0] = 2*lastCoord[0] - lastControl[0];\n            r[1] = 2*lastCoord[1] - lastControl[1];\n            return r;\n          }\n    \n          function makeAbsoluteFromX(c, x) {\n            var coord = [x, 0];\n            if (c == 'H') {\n              coord[1] = lastCoord[1];\n            }\n            return makeAbsolute(c, coord);\n          }\n    \n          function makeAbsoluteFromY(c, y) {\n            var coord = [0, y];\n            if (c == 'V') {\n              coord[0] = lastCoord[0];\n            }\n            return makeAbsolute(c, coord);\n          }\n    \n          function concatSequence(one, rest) {\n            var r = [one];\n            if (rest && rest.length > 1) {\n              var rem = rest[1];\n              for (var i = 0; i < rem.length; i++) {\n                r.push(rem[i]);\n              }\n            }\n            return r;\n          }\n    \n          function mag(v) {\n            return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n          }\n    \n          function dot(u, v) {\n            return (u[0]*v[0] + u[1]*v[1]);\n          }\n    \n          function ratio(u, v) {\n            return dot(u,v) / (mag(u)*mag(v))\n          }\n\n          function clamp(value, min, max) {\n            return Math.min(Math.max(val, min),max);\n          }\n    \n          function angle(u, v) {\n            var sign = 1.0;\n            if ((u[0]*v[1] - u[1]*v[0]) < 0) {\n              sign = -1.0;\n            }\n            return sign * Math.acos(clamp(ratio(u,v)), -1, 1);\n          }\n    \n          function rotClockwise(v, angle) {\n            var cost = Math.cos(angle);\n            var sint = Math.sin(angle);\n            return [cost*v[0] + sint*v[1], -1 * sint*v[0] + cost*v[1]];\n          }\n    \n          function rotCounterClockwise(v, angle) {\n            var cost = Math.cos(angle);\n            var sint = Math.sin(angle);\n            return [cost*v[0] - sint*v[1], sint*v[0] + cost*v[1]];\n          }\n    \n          function midPoint(u, v) {\n            return [(u[0] - v[0])/2.0, (u[1] - v[1])/2.0];\n          }\n    \n          function meanVec(u, v) {\n            return [(u[0] + v[0])/2.0, (u[1] + v[1])/2.0];\n          }\n    \n          function pointMul(u, v) {\n            return [u[0]*v[0], u[1]*v[1]];\n          }\n    \n          function scale(c, v) {\n            return [c*v[0], c*v[1]];\n          }\n    \n          function sum(u, v) {\n            return [u[0] + v[0], u[1] + v[1]];\n          }\n    \n          // Convert an SVG elliptical arc to a series of canvas commands.\n          //\n          // x1, x2: start and stop coordinates of the ellipse.\n          // rx, ry: radii of the ellipse.\n          // phi: rotation of the ellipse.\n          // fA: large arc flag.\n          // fS: sweep flag.\n          function ellipseFromEllipticalArc(x1, rx, ry, phi, fA, fS, x2) {\n            // Convert from endpoint to center parametrization, as detailed in:\n            //   http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n            if (rx == 0 || ry == 0) {\n              ops.push({type: 'lineTo', args: x2});\n              return;\n            }\n            var phi = phi * (Math.PI / 180.0);\n            rx = Math.abs(rx);\n            ry = Math.abs(ry);\n            var xPrime = rotClockwise(midPoint(x1, x2), phi);                // F.6.5.1\n            var xPrime2 = pointMul(xPrime, xPrime);\n            var rx2 = Math.pow(rx, 2);\n            var ry2 = Math.pow(ry, 2);\n    \n            var lambda = Math.sqrt(xPrime2[0]/rx2 + xPrime2[1]/ry2);\n            if (lambda > 1) {\n              rx *= lambda;\n              ry *= lambda;\n              rx2 = Math.pow(rx, 2);\n              ry2 = Math.pow(ry, 2);\n            }\n            var factor = Math.sqrt(Math.abs(rx2*ry2 - rx2*xPrime2[1] - ry2*xPrime2[0]) /\n              (rx2*xPrime2[1] + ry2*xPrime2[0]));\n            if (fA == fS) {\n              factor *= -1.0;\n            }\n            var cPrime = scale(factor, [rx*xPrime[1]/ry, -ry*xPrime[0]/rx]); // F.6.5.2\n            var c = sum(rotCounterClockwise(cPrime, phi), meanVec(x1, x2));  // F.6.5.3\n            var x1UnitVector = [(xPrime[0] - cPrime[0])/rx, (xPrime[1] - cPrime[1])/ry];\n            var x2UnitVector = [(-1.0*xPrime[0] - cPrime[0])/rx, (-1.0*xPrime[1] - cPrime[1])/ry];\n            var theta = angle([1, 0], x1UnitVector);                         // F.6.5.5\n            var deltaTheta = angle(x1UnitVector, x2UnitVector);              // F.6.5.6\n            var start = theta;\n            var end = theta+deltaTheta;\n            ops.push(\n              {type: 'save', args: []},\n              {type: 'translate', args: [c[0], c[1]]},\n              {type: 'rotate', args: [phi]},\n              {type: 'scale', args: [rx, ry]},\n              {type: 'arc', args: [0, 0, 1, start, end, 1-fS]},\n              {type: 'restore', args: []}\n              );\n          }\n    \n    \n        peg$result = peg$startRuleFunction();\n    \n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail({ type: \"end\", description: \"end of input\" });\n          }\n    \n          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n        }\n      }\n    \n      return {\n        SyntaxError: SyntaxError,\n        parse:       parse\n      };\n    })();\n\n    function Path_(arg) {\n      this.ops_ = [];\n      if (arg == undefined) {\n        return;\n      }\n      if (typeof arg == 'string') {\n        try {\n          this.ops_ = parser.parse(arg);\n        } catch(e) {\n          // Treat an invalid SVG path as an empty path.\n        }\n      } else if (arg.hasOwnProperty('ops_')) {\n        this.ops_ = arg.ops_.slice(0);\n      } else {\n        throw 'Error: ' + typeof arg + 'is not a valid argument to Path';\n      }\n    };\n\n    // TODO(jcgregorio) test for arcTo and implement via something.\n\n\n    // Path methods that map simply to the CanvasRenderingContext2D.\n    var simple_mapping = [\n      'closePath',\n      'moveTo',\n      'lineTo',\n      'quadraticCurveTo',\n      'bezierCurveTo',\n      'rect',\n      'arc',\n      'arcTo',\n      'ellipse',\n      'isPointInPath',\n      'isPointInStroke',\n      ];\n\n    function createFunction(name) {\n      return function() {\n        this.ops_.push({type: name, args: Array.prototype.slice.call(arguments, 0)});\n      };\n    }\n\n    // Add simple_mapping methods to Path2D.\n    for (var i=0; i<simple_mapping.length; i++) {\n      var name = simple_mapping[i];\n      Path_.prototype[name] = createFunction(name);\n    }\n\n    Path_.prototype['addPath'] = function(path, tr) {\n      var hasTx = false;\n      if (tr\n          && tr.a != undefined\n          && tr.b != undefined\n          && tr.c != undefined\n          && tr.d != undefined\n          && tr.e != undefined\n          && tr.f != undefined) {\n        hasTx = true;\n        this.ops_.push({type: 'save', args: []});\n        this.ops_.push({type: 'transform', args: [tr.a, tr.b, tr.c, tr.d, tr.e, tr.f]});\n      }\n      this.ops_ = this.ops_.concat(path.ops_);\n      if (hasTx) {\n        this.ops_.push({type: 'restore', args: []});\n      }\n    }\n\n    original_fill = CanvasRenderingContext2D.prototype.fill;\n    original_stroke = CanvasRenderingContext2D.prototype.stroke;\n    original_clip = CanvasRenderingContext2D.prototype.clip;\n    original_is_point_in_path = CanvasRenderingContext2D.prototype.isPointInPath;\n    original_is_point_in_stroke = CanvasRenderingContext2D.prototype.isPointInStroke;\n\n    // Replace methods on CanvasRenderingContext2D with ones that understand Path2D.\n    CanvasRenderingContext2D.prototype.fill = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        original_fill.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        original_fill.apply(this, arguments);\n      }\n    }\n\n    CanvasRenderingContext2D.prototype.stroke = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        original_stroke.call(this);\n      } else {\n        original_stroke.call(this);\n      }\n    }\n\n    CanvasRenderingContext2D.prototype.clip = function(arg) {\n      if (arg instanceof Path_) {\n        // Note that we don't save and restore the context state, since the\n        // clip region is part of the state. Not really a problem since the\n        // HTML 5 spec doesn't say that clip(path) doesn't affect the current\n        // path.\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        original_clip.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        original_clip.apply(this, arguments);\n      }\n    }\n\n    CanvasRenderingContext2D.prototype.isPointInPath = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        return original_is_point_in_path.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        return original_is_point_in_path.apply(this, arguments);\n      }\n    }\n    CanvasRenderingContext2D.prototype.isPointInStroke = function(arg) {\n      if (arg instanceof Path_) {\n        this.beginPath();\n        for (var i = 0, len = arg.ops_.length; i < len; i++) {\n          var op = arg.ops_[i];\n          CanvasRenderingContext2D.prototype[op.type].apply(this, op.args);\n        }\n        return original_is_point_in_stroke.apply(this, Array.prototype.slice.call(arguments, 1));\n      } else {\n        return original_is_point_in_stroke.apply(this, arguments);\n      }\n    }\n\n    // Set up externs.\n    Path2D = Path_;\n  })();\n}\n\n})(\n  typeof CanvasRenderingContext2D === \"undefined\" ? undefined : CanvasRenderingContext2D,\n  typeof require === \"undefined\" ? undefined : require\n);\n","import rough from \"../node_modules/roughjs/bin/rough\";\nimport \"../node_modules/canvas-5-polyfill/canvas\";\n\nvar RoughCanvas = L.Canvas.extend({\n  _initContainer: function () {\n    L.Canvas.prototype._initContainer.call(this);\n    this._rc = rough.canvas(this._container);\n  },\n\n  _updatePoly: function (layer, closed) {\n    if (!this._drawing) {\n      return;\n    }\n\n    var parts = layer._parts,\n      len = parts.length,\n      ctx = this._ctx;\n\n    if (!len) {\n      return;\n    }\n\n    var options = layer.options;\n    var pathOption = {};\n\n    pathOption.roughness = options.roughness || 1;\n    pathOption.bowing = options.bowing || 1;\n    pathOption.stroke = options.strokeColor || \"#000000\";\n    pathOption.strokeWidth = options.strokeWidth || 1;\n    if (closed) {\n      pathOption.fill = options.fillColor || options.color;\n      pathOption.fillStyle = options.fillStyle || \"\";\n      pathOption.fillWeight = options.fillWeight || \"\";\n      pathOption.hachureAngle = options.hachureAngle || -41;\n      pathOption.hachureGap = options.hachureGap || 4;\n      pathOption.simplification = options.simplification || 0.5;\n    }\n    pathOption.curveStepCount = options.curveStepCount || 9;\n\n    var svgPathStr = L.SVG.pointsToPath(parts, closed);\n    this._rc.path(svgPathStr, pathOption);\n\n    layer.options.fillOpacity = 0;\n    // layer.options.opacity = 0;\n    L.Canvas.prototype._updatePoly.call(this, layer, closed);\n  },\n\n  _onClick: function (e) {\n    var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;\n    console.log(point);\n\n\t\tfor (var order = this._drawFirst; order; order = order.next) {\n\t\t\tlayer = order.layer;\n\t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n\t\t\t\tif (!(e.type === 'click' || e.type !== 'preclick') || !this._map._draggableMoved(layer)) {\n\t\t\t\t\tclickedLayer = layer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (clickedLayer)  {\n\t\t\tDomEvent.fakeStop(e);\n\t\t\tthis._fireEvent([clickedLayer], e);\n\t\t}\n\t},\n});\n\nL.Canvas.RoughCanvas = RoughCanvas;\n\nL.Canvas.roughCanvas = () => {\n  return new RoughCanvas();\n};\n"],"names":["isType","token","type","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","ParsedPath","[object Object]","d","this","COMMAND","NUMBER","EOD","segments","parseData","processPoints","tokens","Array","match","substr","RegExp","$1","length","text","console","error","parseFloat","tokenize","index","mode","param_length","params","i","numbeToken","segment","key","data","push","closed","_closed","toLowerCase","first","currentPoint","point","RoughPath","_position","_first","bezierReflectionPoint","quadReflectionPoint","parsed","linearPoints","_linearPoints","lp","points","x","y","position","RoughArcConverter","from","to","radii","angle","largeArcFlag","sweepFlag","_segIndex","_numSegs","_rx","_ry","_sinPhi","_cosPhi","_C","_theta","_delta","_T","_from","radPerDeg","Math","PI","abs","sin","cos","x1dash","y1dash","root","numerator","sqrt","cxdash","cydash","calculateVectorAngle","dtheta","ceil","cosTheta1","sinTheta1","theta2","cosTheta2","sinTheta2","cp1","cp2","ux","uy","vx","vy","ta","atan2","tb","PathFitter","sets","simplification","outSets","set","estLength","floor","reduce","p1","p2","pow","count","slice","minArea","minIndex","distance","b","area","splice","Segment","xi","Number","MAX_VALUE","yi","px1","py1","px2","py2","_undefined","otherSegment","isUndefined","grad1","grad2","int1","int2","min","max","HachureIterator","top","bottom","left","right","gap","sinAngle","cosAngle","tanAngle","deltaX","hGap","pos","sLeft","sRight","line","xLower","xUpper","yLower","yUpper","intersects","lineLength","getIntersectingLines","intersections","s1","s2","affine","cx","cy","sinAnglePrime","cosAnglePrime","R","hachureLinesForPolygon","o","ret","hachureAngle","hachureGap","strokeWidth","tan","it","rect","nextLine","lines","hachureLinesForEllipse","width","height","renderer","rx","ry","getOffset","fweight","fillWeight","aspectRatio","hyp","gapPrime","halfLen","xPos","HachureFiller","_fillPolygon","_fillEllipse","connectEnds","ops","renderLines","prevPoint","concat","doubleLine","ZigZagFiller","HatchFiller","o2","Object","assign","set2","DotFiller","curveStepCount","dotsOnLines","dl","alpha","atan","dy","dx","ellipse","fillers","getFiller","fillerName","fillStyle","RoughRenderer","x1","y1","x2","y2","close","len","linearPath","polygon","o1","_curveWithOffset","roughness","increment","_ellipse","start","stop","roughClosure","strt","stp","ellipseInc","arcInc","_arc","op","path","replace","p","fit","prev","opList","_processSegment","offset","maxRandomnessOffset","fillPolygon","fillEllipse","patternFillPolygon","random","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","closePoint","curveTightness","cachedVertArray","ro","overlap","radOffset","_curve","ps","ros","f","setPosition","seg","prevSeg","delta","ob","_bezierTo","prevKey","ref","offset1","offset2","arcConverter","getNextSegment","hasSelf","self","roughScript","document","currentScript","src","RoughGeneratorBase","config","surface","defaultOptions","stroke","workly","async","noWorker","worklySource","worklyURL","code","ourl","URL","createObjectURL","Blob","proxy","createRenderer","options","_options","shape","lib","val","w","baseVal","value","size","ns","svg","createElementNS","setAttribute","pathNode","appendChild","body","bb","getBBox","removeChild","err","canvasSize","getCanvasSize","drawable","paths","drawing","opsToPath","fill","fillSketch","pattern","viewBox","round","patternUnits","item","trim","RoughGenerator","super","_drawable","solidFillPolygon","rectangle","patternFillEllipse","diameter","arc","patternFillArc","curve","computePolygonSize","fillPoints","polygonPath","computePathSize","svgPath","hasDocument","RoughCanvasBase","canvas","ctx","getContext","getDefaultOptions","save","strokeStyle","lineWidth","_drawToContext","restore","p2d","Path2D","doc","ownerDocument","hcanvas","createElement","hcontext","bbox","computeBBox","translate","createPattern","beginPath","moveTo","bezierCurveTo","quadraticCurveTo","lineTo","RoughCanvas","gen","generator","draw","circle","RoughGeneratorAsync","RoughCanvasAsync","genAsync","RoughSVGBase","defs","_defs","dnode","firstChild","insertBefore","g","style","id","MAX_SAFE_INTEGER","patternPath","RoughSVG","RoughSVGAsync","CanvasRenderingContext2D","nodeRequire","undefined","Context2d","prototype","radiusX","radiusY","rotation","startAngle","endAngle","antiClockwise","rotate","scale","addPath","Path_","arg","ops_","parser","parse","e","hasOwnProperty","SyntaxError","message","expected","found","column","name","child","parent","ctor","constructor","peg$subclass","Error","input","peg$result","arguments","peg$FAILED","peg$startRuleFunctions","svg_path","peg$parsesvg_path","peg$startRuleFunction","peg$c0","peg$c2","peg$c3","peg$c4","peg$c5","description","peg$c6","ch","args","moveCh","firstSubPath","makeAbsolute","peg$c7","one","rest","concatSequence","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","makeAbsoluteFromX","peg$c17","peg$c18","peg$c19","makeAbsoluteFromY","peg$c20","peg$c21","peg$c22","makeAbsoluteMultiple","peg$c23","last","peg$c24","peg$c25","peg$c26","makeReflected","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","reflected","lastControl","peg$c34","peg$c35","peg$c36","lastCoord","absArgs","ellipseFromEllipticalArc","apply","peg$c37","xrot","large","sweep","flatten","join","parseInt","peg$c38","peg$c39","number","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","digits","peg$c57","peg$c58","peg$currPos","peg$cachedPos","peg$cachedPosDetails","seenCR","peg$maxFailPos","peg$maxFailExpected","startRule","peg$computePosDetails","details","startPos","endPos","charAt","advance","peg$fail","peg$buildException","posDetails","sort","cleanupExpected","expectedDescs","hex","charCodeAt","toString","toUpperCase","stringEscape","buildMessage","s0","s3","s4","peg$parsewsp","peg$parsemoveTo_drawTo_commandGroups","peg$parsemoveTo_drawTo_commandGroup","peg$parsemoveto","peg$parsedrawto_commands","peg$parsedrawto_command","peg$parseclosepath","peg$parselineto","peg$parsehorizontal_lineto","peg$parsevertical_lineto","peg$parsecurveto","peg$parsesmooth_curveto","peg$parsequadratic_bezier_curveto","peg$parsesmooth_quadratic_bezier_curveto","peg$parseelliptical_arc","test","peg$parsemoveto_argument_sequence","peg$parsecoordinate_pair","peg$parsecomma_wsp","peg$parselineto_argument_sequence","peg$parsecoordinate_sequence","peg$parsecoordinate","peg$parsecurveto_argument_sequence","peg$parsecurveto_argument","s5","peg$parsesmooth_curveto_argument_sequence","peg$parsesmooth_curveto_argument","peg$parsequadratic_bezier_curveto_argument_sequence","peg$parsequadratic_bezier_curveto_argument","peg$parsesmooth_quadratic_bezier_curveto_argument_sequence","peg$parseelliptical_arc_argument_sequence","peg$parseelliptical_arc_argument","s7","s8","s9","s10","s11","peg$parsenonnegative_number","peg$parsenumber","peg$parseflag","peg$parsefloating_point_constant","peg$parsedigit_sequence","peg$parsesign","peg$parsecomma","peg$parsefractional_constant","peg$parseexponent","lastCh","flat","coord","indexOf","seq","r","lastPosCopy","rem","mag","dot","u","ratio","clamp","sign","acos","rotClockwise","cost","sint","rotCounterClockwise","midPoint","meanVec","pointMul","sum","phi","fA","fS","xPrime","xPrime2","rx2","ry2","lambda","factor","cPrime","x1UnitVector","x2UnitVector","theta","end","simple_mapping","createFunction","call","tr","hasTx","original_fill","original_stroke","original_clip","clip","original_is_point_in_path","isPointInPath","original_is_point_in_stroke","isPointInStroke","require","Canvas","extend","_initContainer","_rc","rough","_container","_updatePoly","layer","_drawing","parts","_parts","_ctx","pathOption","strokeColor","fillColor","color","svgPathStr","SVG","pointsToPath","fillOpacity","_onClick","clickedLayer","_map","mouseEventToLayerPoint","log","order","_drawFirst","next","interactive","_containsPoint","_draggableMoved","DomEvent","fakeStop","_fireEvent","roughCanvas"],"mappings":"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"}